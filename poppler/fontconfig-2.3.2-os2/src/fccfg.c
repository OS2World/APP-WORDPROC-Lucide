/*
 * $RCSId: xc/lib/fontconfig/src/fccfg.c,v 1.23 2002/08/31 22:17:32 keithp Exp $
 *
 * Copyright © 2000 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include "fcint.h"

#if defined (_WIN32) && (defined (PIC) || defined (DLL_EXPORT))
#define STRICT
#include <windows.h>
#undef STRICT
#endif

#if defined (_WIN32) && !defined (R_OK)
#define R_OK 4
#endif

#ifdef __OS2__
#define INCL_WINDIALOGS
#include <os2.h>
#define DEFAULT_OS2_CONFIG_FILE \
  "<?xml version=\"1.0\"?>\n" \
"<!DOCTYPE fontconfig SYSTEM \"fonts.dtd\">\n" \
"<!-- /etc/fonts/fonts.conf file to configure system font access -->\n" \
"<fontconfig>\n" \
"\n" \
"<!--\n" \
"	DO NOT EDIT THIS FILE.\n" \
"	IT WILL BE REPLACED WHEN FONTCONFIG IS UPDATED.\n" \
"	LOCAL CHANGES BELONG IN 'local.conf'.\n" \
"\n" \
"	The intent of this standard configuration file is to be adequate for\n" \
"	most environments.  If you have a reasonably normal environment and\n" \
"	have found problems with this configuration, they are probably\n" \
"	things that others will also want fixed.  Please submit any\n" \
"	problems to the fontconfig bugzilla system located at fontconfig.org\n" \
"\n" \
"	Note that the normal 'make install' procedure for fontconfig is to\n" \
"	replace any existing fonts.conf file with the new version.  Place\n" \
"	any local customizations in local.conf which this file references.\n" \
"\n" \
"	Keith Packard\n" \
"-->\n" \
"\n" \
"<!-- Font directory list -->\n" \
"\n" \
"	<dir></dir>\n" \
"\n" \
"<!--\n" \
"  Accept deprecated 'mono' alias, replacing it with 'monospace'\n" \
"-->\n" \
"	<match target=\"pattern\">\n" \
"		<test qual=\"any\" name=\"family\">\n" \
"			<string>mono</string>\n" \
"		</test>\n" \
"		<edit name=\"family\" mode=\"assign\">\n" \
"			<string>monospace</string>\n" \
"		</edit>\n" \
"	</match>\n" \
"\n" \
"<!--\n" \
"  Accept alternate 'sans serif' spelling, replacing it with 'sans-serif'\n" \
"-->\n" \
"	<match target=\"pattern\">\n" \
"		<test qual=\"any\" name=\"family\">\n" \
"			<string>sans serif</string>\n" \
"		</test>\n" \
"		<edit name=\"family\" mode=\"assign\">\n" \
"			<string>sans-serif</string>\n" \
"		</edit>\n" \
"	</match>\n" \
"\n" \
"<!--\n" \
"  Accept deprecated 'sans' alias, replacing it with 'sans-serif'\n" \
"-->\n" \
"	<match target=\"pattern\">\n" \
"		<test qual=\"any\" name=\"family\">\n" \
"			<string>sans</string>\n" \
"		</test>\n" \
"		<edit name=\"family\" mode=\"assign\">\n" \
"			<string>sans-serif</string>\n" \
"		</edit>\n" \
"	</match>\n" \
"\n" \
"<!--\n" \
"  Mark common families with their generics so we'll get\n" \
"  something reasonable\n" \
"-->\n" \
"\n" \
"<!--\n" \
"  Serif faces\n" \
" -->\n" \
"	<alias>\n" \
"		<family>Bitstream Vera Serif</family>\n" \
"		<family>Times New Roman</family>\n" \
"		<family>Thorndale AMT</family>\n" \
"		<family>Times</family>\n" \
"		<family>Nimbus Roman No9 L</family>\n" \
"		<family>Luxi Serif</family>\n" \
"		<family>Kochi Mincho</family>\n" \
"		<family>AR PL SungtiL GB</family>\n" \
"		<family>AR PL Mingti2L Big5</family>\n" \
"		<family>ＭＳ 明朝</family>\n" \
"		<family>Baekmuk Batang</family>\n" \
"		<family>FreeSerif</family>\n" \
"		<default><family>serif</family></default>\n" \
"	</alias>\n" \
"<!--\n" \
"  Sans-serif faces\n" \
" -->\n" \
"	<alias>\n" \
"		<family>Bitstream Vera Sans</family>\n" \
"		<family>Helvetica</family>\n" \
"		<family>Arial</family>\n" \
"		<family>Verdana</family>\n" \
"		<family>Albany AMT</family>\n" \
"		<family>Nimbus Sans L</family>\n" \
"		<family>Luxi Sans</family>\n" \
"		<family>Kochi Gothic</family>\n" \
"		<family>AR PL KaitiM GB</family>\n" \
"		<family>AR PL KaitiM Big5</family>\n" \
"		<family>ＭＳ ゴシック</family>\n" \
"		<family>Baekmuk Dotum</family>\n" \
"		<family>SimSun</family>\n" \
"		<family>FreeSans</family>\n" \
"		<default><family>sans-serif</family></default>\n" \
"	</alias>\n" \
"<!--\n" \
"  Monospace faces\n" \
" -->\n" \
" 	<alias>\n" \
"		<family>Bitstream Vera Sans Mono</family>\n" \
"		<family>Courier</family>\n" \
"		<family>Courier New</family>\n" \
"		<family>Andale Mono</family>\n" \
"		<family>Luxi Mono</family>\n" \
"		<family>Cumberland AMT</family>\n" \
"		<family>Nimbus Mono L</family>\n" \
"		<family>NSimSun</family>\n" \
"		<family>FreeMono</family>\n" \
"		<default><family>monospace</family></default>\n" \
"	</alias>\n" \
"<!--\n" \
"  If the font still has no generic name, add sans-serif\n" \
" -->\n" \
"	<match target=\"pattern\">\n" \
"		<test qual=\"all\" name=\"family\" compare=\"not_eq\">\n" \
"			<string>sans-serif</string>\n" \
"		</test>\n" \
"		<test qual=\"all\" name=\"family\" compare=\"not_eq\">\n" \
"			<string>serif</string>\n" \
"		</test>\n" \
"		<test qual=\"all\" name=\"family\" compare=\"not_eq\">\n" \
"			<string>monospace</string>\n" \
"		</test>\n" \
"		<edit name=\"family\" mode=\"append_last\">\n" \
"			<string>sans-serif</string>\n" \
"		</edit>\n" \
"	</match>\n" \
"\n" \
"<!--\n" \
"  URW provides metric and shape compatible fonts for these 3 Adobe families.\n" \
"  -->\n" \
"        <alias>\n" \
"	  <family>Times</family>\n" \
"	  <accept><family>Nimbus Roman No9 L</family></accept>\n" \
"	</alias>\n" \
"        <alias>\n" \
"	  <family>Helvetica</family>\n" \
"	  <accept><family>Nimbus Sans L</family></accept>\n" \
"	</alias>\n" \
"        <alias>\n" \
"	  <family>Courier</family>\n" \
"	  <accept><family>Nimbus Mono L</family></accept>\n" \
"	</alias>\n" \
"\n" \
"<!--\n" \
" AMT provides metric and shape compatible fonts for these three web font\n" \
" families.\n" \
" -->\n" \
" 	<alias>\n" \
"		<family>Times New Roman</family>\n" \
"		<accept><family>Thorndale AMT</family></accept>\n" \
"	</alias>\n" \
" 	<alias>\n" \
"		<family>Arial</family>\n" \
"		<accept><family>Albany AMT</family></accept>\n" \
"	</alias>\n" \
" 	<alias>\n" \
"		<family>Courier New</family>\n" \
"		<accept><family>Cumberland AMT</family></accept>\n" \
"	</alias>\n" \
" \n" \
"<!--\n" \
"  Some Asian fonts misadvertise themselves as monospaced when\n" \
"  in fact they are dual-spaced (half and full).  This makes\n" \
"  FreeType very confused as it forces all widths to match.\n" \
"  Undo this magic by disabling the width forcing code -->\n" \
"	<match target=\"font\">\n" \
"		<test name=\"family\"><string>GulimChe</string></test>\n" \
"		<edit name=\"globaladvance\"><bool>false</bool></edit>\n" \
"	</match>\n" \
"\n" \
"	<match target=\"font\">\n" \
"		<test name=\"family\"><string>DotumChe</string></test>\n" \
"		<edit name=\"globaladvance\"><bool>false</bool></edit>\n" \
"	</match>\n" \
"\n" \
"	<match target=\"font\">\n" \
"		<test name=\"family\"><string>BatangChe</string></test>\n" \
"		<edit name=\"globaladvance\"><bool>false</bool></edit>\n" \
"	</match>\n" \
"\n" \
"       <match target=\"font\">\n" \
"		<test name=\"family\"><string>GungsuhChe</string></test>\n" \
"		<edit name=\"globaladvance\"><bool>false</bool></edit>\n" \
"	</match>\n" \
"\n" \
"<!-- \n" \
"	The Bitstream Vera fonts have GASP entries suggesting that hinting be\n" \
"	disabled below 8 ppem, but FreeType ignores those, preferring to use\n" \
"	the data found in the instructed hints.  The initial Vera release\n" \
"	didn't include the right instructions in the 'prep' table. Fix this\n" \
"	by disabling hinting manually at smaller sizes (< 8ppem)\n" \
" -->\n" \
"\n" \
"	<match target=\"font\">\n" \
"		<test name=\"family\">\n" \
"			<string>Bitstream Vera Sans</string>\n" \
"		</test>\n" \
"		<test name=\"pixelsize\" compare=\"less\">\n" \
"			<double>7.5</double>\n" \
"		</test>\n" \
"		<edit name=\"hinting\">\n" \
"			<bool>false</bool>\n" \
"		</edit>\n" \
"	</match>\n" \
"\n" \
"	<match target=\"font\">\n" \
"		<test name=\"family\">\n" \
"			<string>Bitstream Vera Serif</string>\n" \
"		</test>\n" \
"		<test name=\"pixelsize\" compare=\"less\">\n" \
"			<double>7.5</double>\n" \
"		</test>\n" \
"		<edit name=\"hinting\">\n" \
"			<bool>false</bool>\n" \
"		</edit>\n" \
"	</match>\n" \
"\n" \
"	<match target=\"font\">\n" \
"		<test name=\"family\">\n" \
"			<string>Bitstream Vera Sans Mono</string>\n" \
"		</test>\n" \
"		<test name=\"pixelsize\" compare=\"less\">\n" \
"			<double>7.5</double>\n" \
"		</test>\n" \
"		<edit name=\"hinting\">\n" \
"			<bool>false</bool>\n" \
"		</edit>\n" \
"	</match>\n" \
"\n" \
"<!--\n" \
"  Provide required aliases for standard names\n" \
"-->\n" \
"	<alias>\n" \
"		<family>serif</family>\n" \
"		<prefer>\n" \
"			<family>Bitstream Vera Serif</family>\n" \
"			<family>Times New Roman</family>\n" \
"			<family>Thorndale AMT</family>\n" \
"			<family>Luxi Serif</family>\n" \
"			<family>Nimbus Roman No9 L</family>\n" \
"			<family>Times</family>\n" \
"			<family>Frank Ruehl</family>\n" \
"			<family>Kochi Mincho</family>\n" \
"			<family>AR PL SungtiL GB</family>\n" \
"			<family>AR PL Mingti2L Big5</family>\n" \
"			<family>ＭＳ 明朝</family>\n" \
"			<family>Baekmuk Batang</family>\n" \
"			<family>FreeSerif</family>\n" \
"		</prefer>\n" \
"	</alias>\n" \
"	<alias>\n" \
"		<family>sans-serif</family>\n" \
"		<prefer>\n" \
"			<family>Bitstream Vera Sans</family>\n" \
"			<family>Verdana</family>\n" \
"			<family>Arial</family>\n" \
"			<family>Albany AMT</family>\n" \
"			<family>Luxi Sans</family>\n" \
"			<family>Nimbus Sans L</family>\n" \
"			<family>Helvetica</family>\n" \
"			<family>Nachlieli</family>\n" \
"			<family>Kochi Gothic</family>\n" \
"			<family>AR PL KaitiM GB</family>\n" \
"			<family>AR PL KaitiM Big5</family>\n" \
"			<family>ＭＳ ゴシック</family>\n" \
"			<family>Baekmuk Dotum</family>\n" \
"			<family>SimSun</family>\n" \
"			<family>FreeSans</family>\n" \
"		</prefer>\n" \
"	</alias>\n" \
"	<alias>\n" \
"		<family>monospace</family>\n" \
"		<prefer>\n" \
"			<family>Bitstream Vera Sans Mono</family>\n" \
"			<family>Andale Mono</family>\n" \
"			<family>Courier New</family>\n" \
"			<family>Cumberland AMT</family>\n" \
"			<family>Luxi Mono</family>\n" \
"			<family>Nimbus Mono L</family>\n" \
"			<family>Courier</family>\n" \
"			<family>Miriam Mono</family>\n" \
"			<family>Kochi Gothic</family>\n" \
"			<family>AR PL KaitiM GB</family>\n" \
"			<family>Baekmuk Dotum</family>\n" \
"			<family>FreeMono</family>\n" \
"		</prefer>\n" \
"	</alias>\n" \
"\n" \
"<!-- \n" \
" Artificial oblique for fonts without an italic or oblique version\n" \
" -->\n" \
" \n" \
"	<match target=\"font\">\n" \
"		<!-- check to see if the font is roman -->\n" \
"		<test name=\"slant\">\n" \
"			<const>roman</const>\n" \
"		</test>\n" \
"		<!-- check to see if the pattern requested non-roman -->\n" \
"		<test target=\"pattern\" name=\"slant\" compare=\"not_eq\">\n" \
"			<const>roman</const>\n" \
"		</test>\n" \
"		<!-- multiply the matrix to slant the font -->\n" \
"		<edit name=\"matrix\" mode=\"assign\">\n" \
"			<times>\n" \
"				<name>matrix</name>\n" \
"				<matrix><double>1</double><double>0.2</double>\n" \
"					<double>0</double><double>1</double>\n" \
"				</matrix>\n" \
"			</times>\n" \
"		</edit>\n" \
"		<!-- pretend the font is oblique now -->\n" \
"		<edit name=\"slant\" mode=\"assign\">\n" \
"			<const>oblique</const>\n" \
"		</edit>\n" \
"	</match>\n" \
"\n" \
"<!--\n" \
" Synthetic emboldening for fonts that do not have bold face available\n" \
" -->\n" \
"\n" \
"	<match target=\"font\">\n" \
"		<!-- check to see if the font is just regular -->\n" \
"		<test name=\"weight\" compare=\"less_eq\">\n" \
"			<int>100</int>\n" \
"		</test>\n" \
"		<!-- check to see if the pattern requests bold -->\n" \
"		<test target=\"pattern\" name=\"weight\" compare=\"more_eq\">\n" \
"			<int>200</int>\n" \
"		</test>\n" \
"		<!-- set the embolden flag -->\n" \
"		<edit name=\"embolden\" mode=\"assign\">\n" \
"			<bool>true</bool>\n" \
"		</edit>\n" \
"	</match>\n" \
"\n" \
"\n" \
"	<config>\n" \
"<!--\n" \
"  These are the default Unicode chars that are expected to be blank\n" \
"  in fonts.  All other blank chars are assumed to be broken and\n" \
"  won't appear in the resulting charsets\n" \
" -->\n" \
"		<blank>\n" \
"			<int>0x0020</int>	<!-- SPACE -->\n" \
"			<int>0x00A0</int>	<!-- NO-BREAK SPACE -->\n" \
"			<int>0x00AD</int>	<!-- SOFT HYPHEN -->\n" \
"			<int>0x034F</int>	<!-- COMBINING GRAPHEME JOINER -->\n" \
"			<int>0x0600</int>	<!-- ARABIC NUMBER SIGN -->\n" \
"			<int>0x0601</int>	<!-- ARABIC SIGN SANAH -->\n" \
"			<int>0x0602</int>	<!-- ARABIC FOOTNOTE MARKER -->\n" \
"			<int>0x0603</int>	<!-- ARABIC SIGN SAFHA -->\n" \
"			<int>0x06DD</int>	<!-- ARABIC END OF AYAH -->\n" \
"			<int>0x070F</int>	<!-- SYRIAC ABBREVIATION MARK -->\n" \
"			<int>0x115F</int>	<!-- HANGUL CHOSEONG FILLER -->\n" \
"			<int>0x1160</int>	<!-- HANGUL JUNGSEONG FILLER -->\n" \
"			<int>0x1680</int>	<!-- OGHAM SPACE MARK -->\n" \
"			<int>0x17B4</int>	<!-- KHMER VOWEL INHERENT AQ -->\n" \
"			<int>0x17B5</int>	<!-- KHMER VOWEL INHERENT AA -->\n" \
"			<int>0x180E</int>	<!-- MONGOLIAN VOWEL SEPARATOR -->\n" \
"			<int>0x2000</int>	<!-- EN QUAD -->\n" \
"			<int>0x2001</int>	<!-- EM QUAD -->\n" \
"			<int>0x2002</int>	<!-- EN SPACE -->\n" \
"			<int>0x2003</int>	<!-- EM SPACE -->\n" \
"			<int>0x2004</int>	<!-- THREE-PER-EM SPACE -->\n" \
"			<int>0x2005</int>	<!-- FOUR-PER-EM SPACE -->\n" \
"			<int>0x2006</int>	<!-- SIX-PER-EM SPACE -->\n" \
"			<int>0x2007</int>	<!-- FIGURE SPACE -->\n" \
"			<int>0x2008</int>	<!-- PUNCTUATION SPACE -->\n" \
"			<int>0x2009</int>	<!-- THIN SPACE -->\n" \
"			<int>0x200A</int>	<!-- HAIR SPACE -->\n" \
"			<int>0x200B</int>	<!-- ZERO WIDTH SPACE -->\n" \
"			<int>0x200C</int>	<!-- ZERO WIDTH NON-JOINER -->\n" \
"			<int>0x200D</int>	<!-- ZERO WIDTH JOINER -->\n" \
"			<int>0x200E</int>	<!-- LEFT-TO-RIGHT MARK -->\n" \
"			<int>0x200F</int>	<!-- RIGHT-TO-LEFT MARK -->\n" \
"			<int>0x2028</int>	<!-- LINE SEPARATOR -->\n" \
"			<int>0x2029</int>	<!-- PARAGRAPH SEPARATOR -->\n" \
"			<int>0x202A</int>	<!-- LEFT-TO-RIGHT EMBEDDING -->\n" \
"			<int>0x202B</int>	<!-- RIGHT-TO-LEFT EMBEDDING -->\n" \
"			<int>0x202C</int>	<!-- POP DIRECTIONAL FORMATTING -->\n" \
"			<int>0x202D</int>	<!-- LEFT-TO-RIGHT OVERRIDE -->\n" \
"			<int>0x202E</int>	<!-- RIGHT-TO-LEFT OVERRIDE -->\n" \
"			<int>0x202F</int>	<!-- NARROW NO-BREAK SPACE -->\n" \
"			<int>0x205F</int>	<!-- MEDIUM MATHEMATICAL SPACE -->\n" \
"			<int>0x2060</int>	<!-- WORD JOINER -->\n" \
"			<int>0x2061</int>	<!-- FUNCTION APPLICATION -->\n" \
"			<int>0x2062</int>	<!-- INVISIBLE TIMES -->\n" \
"			<int>0x2063</int>	<!-- INVISIBLE SEPARATOR -->\n" \
"			<int>0x206A</int>	<!-- INHIBIT SYMMETRIC SWAPPING -->\n" \
"			<int>0x206B</int>	<!-- ACTIVATE SYMMETRIC SWAPPING -->\n" \
"			<int>0x206C</int>	<!-- INHIBIT ARABIC FORM SHAPING -->\n" \
"			<int>0x206D</int>	<!-- ACTIVATE ARABIC FORM SHAPING -->\n" \
"			<int>0x206E</int>	<!-- NATIONAL DIGIT SHAPES -->\n" \
"			<int>0x206F</int>	<!-- NOMINAL DIGIT SHAPES -->\n" \
"			<int>0x3000</int>	<!-- IDEOGRAPHIC SPACE -->\n" \
"			<int>0x3164</int>	<!-- HANGUL FILLER -->\n" \
"			<int>0xFEFF</int>	<!-- ZERO WIDTH NO-BREAK SPACE -->\n" \
"			<int>0xFFA0</int>	<!-- HALFWIDTH HANGUL FILLER -->\n" \
"			<int>0xFFF9</int>	<!-- INTERLINEAR ANNOTATION ANCHOR -->\n" \
"			<int>0xFFFA</int>	<!-- INTERLINEAR ANNOTATION SEPARATOR -->\n" \
"			<int>0xFFFB</int>	<!-- INTERLINEAR ANNOTATION TERMINATOR -->\n" \
"		</blank>\n" \
"<!--\n" \
"  Rescan configuration every 30 seconds when FcFontSetList is called\n" \
" -->\n" \
"		<rescan>\n" \
"			<int>30</int>\n" \
"		</rescan>\n" \
"	</config>\n" \
"\n" \
"</fontconfig>\n" \
"\n"
#endif

FcConfig    *_fcConfig;

FcConfig *
FcConfigCreate (void)
{
    FcSetName	set;
    FcConfig	*config;

    config = malloc (sizeof (FcConfig));
    if (!config)
	goto bail0;
    FcMemAlloc (FC_MEM_CONFIG, sizeof (FcConfig));
    
    config->configDirs = FcStrSetCreate ();
    if (!config->configDirs)
	goto bail1;
    
    config->configFiles = FcStrSetCreate ();
    if (!config->configFiles)
	goto bail2;
    
    config->fontDirs = FcStrSetCreate ();
    if (!config->fontDirs)
	goto bail3;
    
    config->acceptGlobs = FcStrSetCreate ();
    if (!config->acceptGlobs)
	goto bail4;

    config->rejectGlobs = FcStrSetCreate ();
    if (!config->rejectGlobs)
	goto bail5;

    config->acceptPatterns = FcFontSetCreate ();
    if (!config->acceptPatterns)
	goto bail6;
    
    config->rejectPatterns = FcFontSetCreate ();
    if (!config->rejectPatterns)
	goto bail7;

    config->cache = 0;
#ifdef __OS2__
    {
      char *pchHome = FcConfigHome();
      if (pchHome)
      {
        char *pchFullPath = malloc(strlen(pchHome)+strlen(FC_USER_CACHE_FILE)+10);
        int rc;

        if (!pchFullPath)
          goto bail8;
        if (pchHome[strlen(pchHome)-1]!='\\')
          sprintf(pchFullPath, "%s\\%s", pchHome, FC_USER_CACHE_FILE);
        else
          sprintf(pchFullPath, "%s%s", pchHome, FC_USER_CACHE_FILE);

        rc = FcConfigSetCache (config, (FcChar8 *) pchFullPath);
        free(pchFullPath);

	if (!rc)
          goto bail8;
      }
    }
#else
    if (FcConfigHome())
	if (!FcConfigSetCache (config, (FcChar8 *) ("~/" FC_USER_CACHE_FILE)))
	    goto bail8;
#endif

#ifdef _WIN32
    if (config->cache == 0)
    {
	/* If no home, use the temp folder. */
	FcChar8	    dummy[1];
	int	    templen = GetTempPath (1, dummy);
	FcChar8     *temp = malloc (templen + 1);

	if (temp)
	{
	    FcChar8 *cache_dir;

	    GetTempPath (templen + 1, temp);
	    cache_dir = FcStrPlus (temp, FC_USER_CACHE_FILE);
	    free (temp);
	    if (!FcConfigSetCache (config, cache_dir))
	    {
		FcStrFree (cache_dir);
		goto bail6;
	    }
	    FcStrFree (cache_dir);
	}
    }
#endif

    config->blanks = 0;

    config->substPattern = 0;
    config->substFont = 0;
    config->maxObjects = 0;
    for (set = FcSetSystem; set <= FcSetApplication; set++)
	config->fonts[set] = 0;

    config->rescanTime = time(0);
    config->rescanInterval = 30;    
    
    return config;

bail8:
    FcFontSetDestroy (config->rejectPatterns);
bail7:
    FcFontSetDestroy (config->acceptPatterns);
bail6:
    FcStrSetDestroy (config->rejectGlobs);
bail5:
    FcStrSetDestroy (config->acceptGlobs);
bail4:
    FcStrSetDestroy (config->fontDirs);
bail3:
    FcStrSetDestroy (config->configFiles);
bail2:
    FcStrSetDestroy (config->configDirs);
bail1:
    free (config);
    FcMemFree (FC_MEM_CONFIG, sizeof (FcConfig));
bail0:
    return 0;
}

typedef struct _FcFileTime {
    time_t  time;
    FcBool  set;
} FcFileTime;

static FcFileTime
FcConfigNewestFile (FcStrSet *files)
{
    FcStrList	    *list = FcStrListCreate (files);
    FcFileTime	    newest = { 0, FcFalse };
    FcChar8	    *file;
    struct  stat    statb;

    if (list)
    {
	while ((file = FcStrListNext (list)))
	    if (stat ((char *) file, &statb) == 0)
		if (!newest.set || statb.st_mtime - newest.time > 0)
		{
		    newest.set = FcTrue;
		    newest.time = statb.st_mtime;
		}
	FcStrListDone (list);
    }
    return newest;
}

FcBool
FcConfigUptoDate (FcConfig *config)
{
    FcFileTime	config_time, font_time;
    time_t	now = time(0);
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return FcFalse;
    }
    config_time = FcConfigNewestFile (config->configFiles);
    font_time = FcConfigNewestFile (config->fontDirs);
    if ((config_time.set && config_time.time - config->rescanTime > 0) ||
	(font_time.set && (font_time.time - config->rescanTime) > 0))
    {
	return FcFalse;
    }
    config->rescanTime = now;
    return FcTrue;
}

static void
FcSubstDestroy (FcSubst *s)
{
    FcSubst *n;
    
    while (s)
    {
	n = s->next;
	if (s->test)
	    FcTestDestroy (s->test);
	if (s->edit)
	    FcEditDestroy (s->edit);
	free (s);
	FcMemFree (FC_MEM_SUBST, sizeof (FcSubst));
	s = n;
    }
}

void
FcConfigDestroy (FcConfig *config)
{
    FcSetName	set;

    if (config == _fcConfig)
	_fcConfig = 0;

    FcStrSetDestroy (config->configDirs);
    FcStrSetDestroy (config->fontDirs);
    FcStrSetDestroy (config->configFiles);
    FcStrSetDestroy (config->acceptGlobs);
    FcStrSetDestroy (config->rejectGlobs);
    FcFontSetDestroy (config->acceptPatterns);
    FcFontSetDestroy (config->rejectPatterns);

    if (config->blanks)
	FcBlanksDestroy (config->blanks);

    if (config->cache)
	FcStrFree (config->cache);

    FcSubstDestroy (config->substPattern);
    FcSubstDestroy (config->substFont);
    for (set = FcSetSystem; set <= FcSetApplication; set++)
	if (config->fonts[set])
	    FcFontSetDestroy (config->fonts[set]);

    free (config);
    FcMemFree (FC_MEM_CONFIG, sizeof (FcConfig));
}

/*
 * Scan the current list of directories in the configuration
 * and build the set of available fonts. Update the
 * per-user cache file to reflect the new configuration
 */

FcBool
FcConfigBuildFonts (FcConfig *config)
{
    FcFontSet	    *fonts;
    FcGlobalCache   *cache;
    FcStrList	    *list;
    FcChar8	    *dir;

    fonts = FcFontSetCreate ();
    if (!fonts)
	goto bail0;
    
    cache = FcGlobalCacheCreate ();
    if (!cache)
	goto bail1;

    if (config->cache)
	FcGlobalCacheLoad (cache, config->cache);

    list = FcConfigGetFontDirs (config);
    if (!list)
	goto bail1;

    while ((dir = FcStrListNext (list)))
    {
	if (FcDebug () & FC_DBG_FONTSET)
	    printf ("scan dir %s\n", dir);
	FcDirScanConfig (fonts, config->fontDirs, cache, 
			 config->blanks, dir, FcFalse, config);
    }
    
    FcStrListDone (list);
    
    if (FcDebug () & FC_DBG_FONTSET)
	FcFontSetPrint (fonts);

    if (config->cache)
	FcGlobalCacheSave (cache, config->cache);
    FcGlobalCacheDestroy (cache);

    FcConfigSetFonts (config, fonts, FcSetSystem);
    
    return FcTrue;
bail1:
    FcFontSetDestroy (fonts);
bail0:
    return FcFalse;
}

FcBool
FcConfigSetCurrent (FcConfig *config)
{
    if (!config->fonts)
	if (!FcConfigBuildFonts (config))
	    return FcFalse;

    if (_fcConfig)
	FcConfigDestroy (_fcConfig);
    _fcConfig = config;
    return FcTrue;
}

FcConfig *
FcConfigGetCurrent (void)
{
    if (!_fcConfig)
	if (!FcInit ())
	    return 0;
    return _fcConfig;
}

FcBool
FcConfigAddConfigDir (FcConfig	    *config,
		      const FcChar8 *d)
{
    return FcStrSetAddFilename (config->configDirs, d);
}

FcStrList *
FcConfigGetConfigDirs (FcConfig   *config)
{
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return 0;
    }
    return FcStrListCreate (config->configDirs);
}

FcBool
FcConfigAddFontDir (FcConfig	    *config,
		    const FcChar8   *d)
{
    return FcStrSetAddFilename (config->fontDirs, d);
}

FcBool
FcConfigAddDir (FcConfig	    *config,
		const FcChar8	    *d)
{
    return (FcConfigAddConfigDir (config, d) && 
	    FcConfigAddFontDir (config, d));
}

FcStrList *
FcConfigGetFontDirs (FcConfig	*config)
{
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return 0;
    }
    return FcStrListCreate (config->fontDirs);
}

FcBool
FcConfigAddConfigFile (FcConfig	    *config,
		       const FcChar8   *f)
{
    FcBool	ret;
    FcChar8	*file = FcConfigFilename (f);
    
    if (!file)
	return FcFalse;
    
    ret = FcStrSetAdd (config->configFiles, file);
    FcStrFree (file);
    return ret;
}

FcStrList *
FcConfigGetConfigFiles (FcConfig    *config)
{
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return 0;
    }
    return FcStrListCreate (config->configFiles);
}

FcBool
FcConfigSetCache (FcConfig	*config,
		  const FcChar8	*c)
{
    FcChar8    *new = FcStrCopyFilename (c);
    
    if (!new)
	return FcFalse;
    if (config->cache)
	FcStrFree (config->cache);
    config->cache = new;
    return FcTrue;
}

FcChar8 *
FcConfigGetCache (FcConfig  *config)
{
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return 0;
    }
    return config->cache;
}

FcFontSet *
FcConfigGetFonts (FcConfig	*config,
		  FcSetName	set)
{
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return 0;
    }
    return config->fonts[set];
}

void
FcConfigSetFonts (FcConfig	*config,
		  FcFontSet	*fonts,
		  FcSetName	set)
{
    if (config->fonts[set])
	FcFontSetDestroy (config->fonts[set]);
    config->fonts[set] = fonts;
}



FcBlanks *
FcConfigGetBlanks (FcConfig	*config)
{
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return 0;
    }
    return config->blanks;
}

FcBool
FcConfigAddBlank (FcConfig	*config,
		  FcChar32    	blank)
{
    FcBlanks	*b;
    
    b = config->blanks;
    if (!b)
    {
	b = FcBlanksCreate ();
	if (!b)
	    return FcFalse;
    }
    if (!FcBlanksAdd (b, blank))
	return FcFalse;
    config->blanks = b;
    return FcTrue;
}

int
FcConfigGetRescanInverval (FcConfig *config)
{
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return 0;
    }
    return config->rescanInterval;
}

FcBool
FcConfigSetRescanInverval (FcConfig *config, int rescanInterval)
{
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return FcFalse;
    }
    config->rescanInterval = rescanInterval;
    return FcTrue;
}

FcBool
FcConfigAddEdit (FcConfig	*config,
		 FcTest		*test,
		 FcEdit		*edit,
		 FcMatchKind	kind)
{
    FcSubst	*subst, **prev;
    FcTest	*t;
    int		num;

    subst = (FcSubst *) malloc (sizeof (FcSubst));
    if (!subst)
	return FcFalse;
    FcMemAlloc (FC_MEM_SUBST, sizeof (FcSubst));
    if (kind == FcMatchPattern)
	prev = &config->substPattern;
    else
	prev = &config->substFont;
    for (; *prev; prev = &(*prev)->next);
    *prev = subst;
    subst->next = 0;
    subst->test = test;
    subst->edit = edit;
    num = 0;
    for (t = test; t; t = t->next)
    {
	if (t->kind == FcMatchDefault)
	    t->kind = kind;
	num++;
    }
    if (config->maxObjects < num)
	config->maxObjects = num;
    if (FcDebug () & FC_DBG_EDIT)
    {
	printf ("Add Subst ");
	FcSubstPrint (subst);
    }
    return FcTrue;
}

typedef struct _FcSubState {
    FcPatternElt   *elt;
    FcValueList    *value;
} FcSubState;

static FcValue
FcConfigPromote (FcValue v, FcValue u)
{
    if (v.type == FcTypeInteger)
    {
	v.type = FcTypeDouble;
	v.u.d = (double) v.u.i;
    }
    else if (v.type == FcTypeVoid && u.type == FcTypeMatrix)
    {
	v.u.m = &FcIdentityMatrix;
	v.type = FcTypeMatrix;
    }
    else if (v.type == FcTypeString && u.type == FcTypeLangSet)
    {
	v.u.l = FcLangSetPromote (v.u.s);
	v.type = FcTypeLangSet;
    }
    return v;
}

FcBool
FcConfigCompareValue (const FcValue	left_o,
		      FcOp		op,
		      const FcValue	right_o)
{
    FcValue	left = left_o;
    FcValue	right = right_o;
    FcBool	ret = FcFalse;
    
    left = FcConfigPromote (left, right);
    right = FcConfigPromote (right, left);
    if (left.type == right.type) 
    {
	switch (left.type) {
	case FcTypeInteger:
	    break;	/* FcConfigPromote prevents this from happening */
	case FcTypeDouble:
	    switch (op) {
	    case FcOpEqual:
	    case FcOpContains:
	    case FcOpListing:
		ret = left.u.d == right.u.d;
		break;
	    case FcOpNotEqual:
	    case FcOpNotContains:
		ret = left.u.d != right.u.d;
		break;
	    case FcOpLess:    
		ret = left.u.d < right.u.d;
		break;
	    case FcOpLessEqual:    
		ret = left.u.d <= right.u.d;
		break;
	    case FcOpMore:    
		ret = left.u.d > right.u.d;
		break;
	    case FcOpMoreEqual:    
		ret = left.u.d >= right.u.d;
		break;
	    default:
		break;
	    }
	    break;
	case FcTypeBool:
	    switch (op) {
	    case FcOpEqual:    
	    case FcOpContains:
	    case FcOpListing:
		ret = left.u.b == right.u.b;
		break;
	    case FcOpNotEqual:
	    case FcOpNotContains:
		ret = left.u.b != right.u.b;
		break;
	    default:
		break;
	    }
	    break;
	case FcTypeString:
	    switch (op) {
	    case FcOpEqual:    
	    case FcOpListing:
		ret = FcStrCmpIgnoreCase (left.u.s, right.u.s) == 0;
		break;
	    case FcOpContains:
		ret = FcStrStrIgnoreCase (left.u.s, right.u.s) != 0;
		break;
	    case FcOpNotEqual:
	    case FcOpNotContains:
		ret = FcStrCmpIgnoreCase (left.u.s, right.u.s) != 0;
		break;
	    default:
		break;
	    }
	    break;
	case FcTypeMatrix:
	    switch (op) {
	    case FcOpEqual:
	    case FcOpContains:
	    case FcOpListing:
		ret = FcMatrixEqual (left.u.m, right.u.m);
		break;
	    case FcOpNotEqual:
	    case FcOpNotContains:
		ret = !FcMatrixEqual (left.u.m, right.u.m);
		break;
	    default:
		break;
	    }
	    break;
	case FcTypeCharSet:
	    switch (op) {
	    case FcOpContains:
	    case FcOpListing:
		/* left contains right if right is a subset of left */
		ret = FcCharSetIsSubset (right.u.c, left.u.c);
		break;
	    case FcOpNotContains:
		/* left contains right if right is a subset of left */
		ret = !FcCharSetIsSubset (right.u.c, left.u.c);
		break;
	    case FcOpEqual:
		ret = FcCharSetEqual (left.u.c, right.u.c);
		break;
	    case FcOpNotEqual:
		ret = !FcCharSetEqual (left.u.c, right.u.c);
		break;
	    default:
		break;
	    }
	    break;
	case FcTypeLangSet:
	    switch (op) {
	    case FcOpContains:
	    case FcOpListing:
		ret = FcLangSetContains (left.u.l, right.u.l);
		break;
	    case FcOpNotContains:
		ret = !FcLangSetContains (left.u.l, right.u.l);
		break;
	    case FcOpEqual:
		ret = FcLangSetEqual (left.u.l, right.u.l);
		break;
	    case FcOpNotEqual:
		ret = !FcLangSetEqual (left.u.l, right.u.l);
		break;
	    default:
		break;
	    }
	    break;
	case FcTypeVoid:
	    switch (op) {
	    case FcOpEqual:
	    case FcOpContains:
	    case FcOpListing:
		ret = FcTrue;
		break;
	    default:
		break;
	    }
	    break;
	case FcTypeFTFace:
	    switch (op) {
	    case FcOpEqual:
	    case FcOpContains:
	    case FcOpListing:
		ret = left.u.f == right.u.f;
		break;
	    case FcOpNotEqual:
	    case FcOpNotContains:
		ret = left.u.f != right.u.f;
		break;
	    default:
		break;
	    }
	    break;
	}
    }
    else
    {
	if (op == FcOpNotEqual || op == FcOpNotContains)
	    ret = FcTrue;
    }
    return ret;
}


#define _FcDoubleFloor(d)	((int) (d))
#define _FcDoubleCeil(d)	((double) (int) (d) == (d) ? (int) (d) : (int) ((d) + 1))
#define FcDoubleFloor(d)	((d) >= 0 ? _FcDoubleFloor(d) : -_FcDoubleCeil(-(d)))
#define FcDoubleCeil(d)		((d) >= 0 ? _FcDoubleCeil(d) : -_FcDoubleFloor(-(d)))
#define FcDoubleRound(d)	FcDoubleFloor ((d) + 0.5)
#define FcDoubleTrunc(d)	((d) >= 0 ? _FcDoubleFloor (d) : -_FcDoubleFloor (-(d)))

static FcValue
FcConfigEvaluate (FcPattern *p, FcExpr *e)
{
    FcValue	v, vl, vr;
    FcResult	r;
    FcMatrix	*m;
    
    switch (e->op) {
    case FcOpInteger:
	v.type = FcTypeInteger;
	v.u.i = e->u.ival;
	break;
    case FcOpDouble:
	v.type = FcTypeDouble;
	v.u.d = e->u.dval;
	break;
    case FcOpString:
	v.type = FcTypeString;
	v.u.s = e->u.sval;
	v = FcValueSave (v);
	break;
    case FcOpMatrix:
	v.type = FcTypeMatrix;
	v.u.m = e->u.mval;
	v = FcValueSave (v);
	break;
    case FcOpCharSet:
	v.type = FcTypeCharSet;
	v.u.c = e->u.cval;
	v = FcValueSave (v);
	break;
    case FcOpBool:
	v.type = FcTypeBool;
	v.u.b = e->u.bval;
	break;
    case FcOpField:
	r = FcPatternGet (p, e->u.field, 0, &v);
	if (r != FcResultMatch)
	    v.type = FcTypeVoid;
	break;
    case FcOpConst:
	if (FcNameConstant (e->u.constant, &v.u.i))
	    v.type = FcTypeInteger;
	else
	    v.type = FcTypeVoid;
	break;
    case FcOpQuest:
	vl = FcConfigEvaluate (p, e->u.tree.left);
	if (vl.type == FcTypeBool)
	{
	    if (vl.u.b)
		v = FcConfigEvaluate (p, e->u.tree.right->u.tree.left);
	    else
		v = FcConfigEvaluate (p, e->u.tree.right->u.tree.right);
	}
	else
	    v.type = FcTypeVoid;
	FcValueDestroy (vl);
	break;
    case FcOpEqual:
    case FcOpNotEqual:
    case FcOpLess:
    case FcOpLessEqual:
    case FcOpMore:
    case FcOpMoreEqual:
    case FcOpContains:
    case FcOpNotContains:
    case FcOpListing:
	vl = FcConfigEvaluate (p, e->u.tree.left);
	vr = FcConfigEvaluate (p, e->u.tree.right);
	v.type = FcTypeBool;
	v.u.b = FcConfigCompareValue (vl, e->op, vr);
	FcValueDestroy (vl);
	FcValueDestroy (vr);
	break;	
    case FcOpOr:
    case FcOpAnd:
    case FcOpPlus:
    case FcOpMinus:
    case FcOpTimes:
    case FcOpDivide:
	vl = FcConfigEvaluate (p, e->u.tree.left);
	vr = FcConfigEvaluate (p, e->u.tree.right);
	vl = FcConfigPromote (vl, vr);
	vr = FcConfigPromote (vr, vl);
	if (vl.type == vr.type)
	{
	    switch (vl.type) {
	    case FcTypeDouble:
		switch (e->op) {
		case FcOpPlus:	   
		    v.type = FcTypeDouble;
		    v.u.d = vl.u.d + vr.u.d; 
		    break;
		case FcOpMinus:
		    v.type = FcTypeDouble;
		    v.u.d = vl.u.d - vr.u.d; 
		    break;
		case FcOpTimes:
		    v.type = FcTypeDouble;
		    v.u.d = vl.u.d * vr.u.d; 
		    break;
		case FcOpDivide:
		    v.type = FcTypeDouble;
		    v.u.d = vl.u.d / vr.u.d; 
		    break;
		default:
		    v.type = FcTypeVoid; 
		    break;
		}
		if (v.type == FcTypeDouble &&
		    v.u.d == (double) (int) v.u.d)
		{
		    v.type = FcTypeInteger;
		    v.u.i = (int) v.u.d;
		}
		break;
	    case FcTypeBool:
		switch (e->op) {
		case FcOpOr:
		    v.type = FcTypeBool;
		    v.u.b = vl.u.b || vr.u.b;
		    break;
		case FcOpAnd:
		    v.type = FcTypeBool;
		    v.u.b = vl.u.b && vr.u.b;
		    break;
		default:
		    v.type = FcTypeVoid; 
		    break;
		}
		break;
	    case FcTypeString:
		switch (e->op) {
		case FcOpPlus:
		    v.type = FcTypeString;
		    v.u.s = FcStrPlus (vl.u.s, vr.u.s);
		    if (!v.u.s)
			v.type = FcTypeVoid;
		    break;
		default:
		    v.type = FcTypeVoid;
		    break;
		}
		break;
	    case FcTypeMatrix:
		switch (e->op) {
		case FcOpTimes:
		    v.type = FcTypeMatrix;
		    m = malloc (sizeof (FcMatrix));
		    if (m)
		    {
			FcMemAlloc (FC_MEM_MATRIX, sizeof (FcMatrix));
			FcMatrixMultiply (m, vl.u.m, vr.u.m);
			v.u.m = m;
		    }
		    else
		    {
			v.type = FcTypeVoid;
		    }
		    break;
		default:
		    v.type = FcTypeVoid;
		    break;
		}
		break;
	    default:
		v.type = FcTypeVoid;
		break;
	    }
	}
	else
	    v.type = FcTypeVoid;
	FcValueDestroy (vl);
	FcValueDestroy (vr);
	break;
    case FcOpNot:
	vl = FcConfigEvaluate (p, e->u.tree.left);
	switch (vl.type) {
	case FcTypeBool:
	    v.type = FcTypeBool;
	    v.u.b = !vl.u.b;
	    break;
	default:
	    v.type = FcTypeVoid;
	    break;
	}
	FcValueDestroy (vl);
	break;
    case FcOpFloor:
	vl = FcConfigEvaluate (p, e->u.tree.left);
	switch (vl.type) {
	case FcTypeInteger:
	    v = vl;
	    break;
	case FcTypeDouble:
	    v.type = FcTypeInteger;
	    v.u.i = FcDoubleFloor (vl.u.d);
	    break;
	default:
	    v.type = FcTypeVoid;
	    break;
	}
	FcValueDestroy (vl);
	break;
    case FcOpCeil:
	vl = FcConfigEvaluate (p, e->u.tree.left);
	switch (vl.type) {
	case FcTypeInteger:
	    v = vl;
	    break;
	case FcTypeDouble:
	    v.type = FcTypeInteger;
	    v.u.i = FcDoubleCeil (vl.u.d);
	    break;
	default:
	    v.type = FcTypeVoid;
	    break;
	}
	FcValueDestroy (vl);
	break;
    case FcOpRound:
	vl = FcConfigEvaluate (p, e->u.tree.left);
	switch (vl.type) {
	case FcTypeInteger:
	    v = vl;
	    break;
	case FcTypeDouble:
	    v.type = FcTypeInteger;
	    v.u.i = FcDoubleRound (vl.u.d);
	    break;
	default:
	    v.type = FcTypeVoid;
	    break;
	}
	FcValueDestroy (vl);
	break;
    case FcOpTrunc:
	vl = FcConfigEvaluate (p, e->u.tree.left);
	switch (vl.type) {
	case FcTypeInteger:
	    v = vl;
	    break;
	case FcTypeDouble:
	    v.type = FcTypeInteger;
	    v.u.i = FcDoubleTrunc (vl.u.d);
	    break;
	default:
	    v.type = FcTypeVoid;
	    break;
	}
	FcValueDestroy (vl);
	break;
    default:
	v.type = FcTypeVoid;
	break;
    }
    return v;
}

static FcValueList *
FcConfigMatchValueList (FcPattern	*p,
			FcTest		*t,
			FcValueList	*values)
{
    FcValueList	    *ret = 0;
    FcExpr	    *e = t->expr;
    FcValue	    value;
    FcValueList	    *v;
    
    while (e)
    {
	/* Compute the value of the match expression */
	if (e->op == FcOpComma)
	{
	    value = FcConfigEvaluate (p, e->u.tree.left);
	    e = e->u.tree.right;
	}
	else
	{
	    value = FcConfigEvaluate (p, e);
	    e = 0;
	}

	for (v = values; v; v = v->next)
	{
	    /* Compare the pattern value to the match expression value */
	    if (FcConfigCompareValue (v->value, t->op, value))
	    {
		if (!ret)
		    ret = v;
	    }
	    else
	    {
		if (t->qual == FcQualAll)
		{
		    ret = 0;
		    break;
		}
	    }
	}
	FcValueDestroy (value);
    }
    return ret;
}

static FcValueList *
FcConfigValues (FcPattern *p, FcExpr *e, FcValueBinding binding)
{
    FcValueList	*l;
    
    if (!e)
	return 0;
    l = (FcValueList *) malloc (sizeof (FcValueList));
    if (!l)
	return 0;
    FcMemAlloc (FC_MEM_VALLIST, sizeof (FcValueList));
    if (e->op == FcOpComma)
    {
	l->value = FcConfigEvaluate (p, e->u.tree.left);
	l->next  = FcConfigValues (p, e->u.tree.right, binding);
    }
    else
    {
	l->value = FcConfigEvaluate (p, e);
	l->next  = 0;
    }
    l->binding = binding;
    while (l && l->value.type == FcTypeVoid)
    {
	FcValueList	*next = l->next;
	
	FcMemFree (FC_MEM_VALLIST, sizeof (FcValueList));
	free (l);
	l = next;
    }
    return l;
}

static FcBool
FcConfigAdd (FcValueList    **head,
	     FcValueList    *position,
	     FcBool	    append,
	     FcValueList    *new)
{
    FcValueList	    **prev, *last, *v;
    FcValueBinding  sameBinding;
    
    if (position)
	sameBinding = position->binding;
    else
	sameBinding = FcValueBindingWeak;
    for (v = new; v; v = v->next)
	if (v->binding == FcValueBindingSame)
	    v->binding = sameBinding;
    if (append)
    {
	if (position)
	    prev = &position->next;
	else
	    for (prev = head; *prev; prev = &(*prev)->next)
		;
    }
    else
    {
	if (position)
	{
	    for (prev = head; *prev; prev = &(*prev)->next)
	    {
		if (*prev == position)
		    break;
	    }
	}
	else
	    prev = head;

	if (FcDebug () & FC_DBG_EDIT)
	{
	    if (!*prev)
		printf ("position not on list\n");
	}
    }

    if (FcDebug () & FC_DBG_EDIT)
    {
	printf ("%s list before ", append ? "Append" : "Prepend");
	FcValueListPrint (*head);
	printf ("\n");
    }
    
    if (new)
    {
	last = new;
	while (last->next)
	    last = last->next;
    
	last->next = *prev;
	*prev = new;
    }
    
    if (FcDebug () & FC_DBG_EDIT)
    {
	printf ("%s list after ", append ? "Append" : "Prepend");
	FcValueListPrint (*head);
	printf ("\n");
    }
    
    return FcTrue;
}

static void
FcConfigDel (FcValueList    **head,
	     FcValueList    *position)
{
    FcValueList    **prev;

    for (prev = head; *prev; prev = &(*prev)->next)
    {
	if (*prev == position)
	{
	    *prev = position->next;
	    position->next = 0;
	    FcValueListDestroy (position);
	    break;
	}
    }
}

static void
FcConfigPatternAdd (FcPattern	*p,
		    const char	*object,
		    FcValueList	*list,
		    FcBool	append)
{
    if (list)
    {
	FcPatternElt    *e = FcPatternInsertElt (p, object);
    
	if (!e)
	    return;
	FcConfigAdd (&e->values, 0, append, list);
    }
}

/*
 * Delete all values associated with a field
 */
static void
FcConfigPatternDel (FcPattern	*p,
		    const char	*object)
{
    FcPatternElt    *e = FcPatternFindElt (p, object);
    if (!e)
	return;
    while (e->values)
	FcConfigDel (&e->values, e->values);
}

static void
FcConfigPatternCanon (FcPattern	    *p,
		      const char    *object)
{
    FcPatternElt    *e = FcPatternFindElt (p, object);
    if (!e)
	return;
    if (!e->values)
	FcPatternDel (p, object);
}

FcBool
FcConfigSubstituteWithPat (FcConfig    *config,
			   FcPattern   *p,
			   FcPattern   *p_pat,
			   FcMatchKind kind)
{
    FcSubst	    *s;
    FcSubState	    *st;
    int		    i;
    FcTest	    *t;
    FcEdit	    *e;
    FcValueList	    *l;
    FcPattern	    *m;

    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return FcFalse;
    }

    st = (FcSubState *) malloc (config->maxObjects * sizeof (FcSubState));
    if (!st && config->maxObjects)
	return FcFalse;
    FcMemAlloc (FC_MEM_SUBSTATE, config->maxObjects * sizeof (FcSubState));

    if (FcDebug () & FC_DBG_EDIT)
    {
	printf ("FcConfigSubstitute ");
	FcPatternPrint (p);
    }
    if (kind == FcMatchPattern)
	s = config->substPattern;
    else
	s = config->substFont;
    for (; s; s = s->next)
    {
	/*
	 * Check the tests to see if
	 * they all match the pattern
	 */
	for (t = s->test, i = 0; t; t = t->next, i++)
	{
	    if (FcDebug () & FC_DBG_EDIT)
	    {
		printf ("FcConfigSubstitute test ");
		FcTestPrint (t);
	    }
	    st[i].elt = 0;
	    if (kind == FcMatchFont && t->kind == FcMatchPattern)
		m = p_pat;
	    else
		m = p;
	    if (m)
		st[i].elt = FcPatternFindElt (m, t->field);
	    else
		st[i].elt = 0;
	    /*
	     * If there's no such field in the font,
	     * then FcQualAll matches while FcQualAny does not
	     */
	    if (!st[i].elt)
	    {
		if (t->qual == FcQualAll)
		{
		    st[i].value = 0;
		    continue;
		}
		else
		    break;
	    }
	    /*
	     * Check to see if there is a match, mark the location
	     * to apply match-relative edits
	     */
	    st[i].value = FcConfigMatchValueList (m, t, st[i].elt->values);
	    if (!st[i].value)
		break;
	    if (t->qual == FcQualFirst && st[i].value != st[i].elt->values)
		break;
	    if (t->qual == FcQualNotFirst && st[i].value == st[i].elt->values)
		break;
	}
	if (t)
	{
	    if (FcDebug () & FC_DBG_EDIT)
		printf ("No match\n");
	    continue;
	}
	if (FcDebug () & FC_DBG_EDIT)
	{
	    printf ("Substitute ");
	    FcSubstPrint (s);
	}
	for (e = s->edit; e; e = e->next)
	{
	    /*
	     * Evaluate the list of expressions
	     */
	    l = FcConfigValues (p, e->expr, e->binding);
	    /*
	     * Locate any test associated with this field, skipping
	     * tests associated with the pattern when substituting in
	     * the font
	     */
	    for (t = s->test, i = 0; t; t = t->next, i++)
	    {
		if ((t->kind == FcMatchFont || kind == FcMatchPattern) &&
		    !FcStrCmpIgnoreCase ((FcChar8 *) t->field, 
					 (FcChar8 *) e->field))
		{
		    /* 
		     * KLUDGE - the pattern may have been reallocated or
		     * things may have been inserted or deleted above
		     * this element by other edits.  Go back and find
		     * the element again
		     */
		    if (e != s->edit && st[i].elt)
			st[i].elt = FcPatternFindElt (p, t->field);
		    if (!st[i].elt)
			t = 0;
		    break;
		}
	    }
	    switch (e->op) {
	    case FcOpAssign:
		/*
		 * If there was a test, then replace the matched
		 * value with the new list of values
		 */
		if (t)
		{
		    FcValueList	*thisValue = st[i].value;
		    FcValueList	*nextValue = thisValue ? thisValue->next : 0;
		    
		    /*
		     * Append the new list of values after the current value
		     */
		    FcConfigAdd (&st[i].elt->values, thisValue, FcTrue, l);
		    /*
		     * Delete the marked value
		     */
		    FcConfigDel (&st[i].elt->values, thisValue);
		    /*
		     * Adjust any pointers into the value list to ensure
		     * future edits occur at the same place
		     */
		    for (t = s->test, i = 0; t; t = t->next, i++)
		    {
			if (st[i].value == thisValue)
			    st[i].value = nextValue;
		    }
		    break;
		}
		/* fall through ... */
	    case FcOpAssignReplace:
		/*
		 * Delete all of the values and insert
		 * the new set
		 */
		FcConfigPatternDel (p, e->field);
		FcConfigPatternAdd (p, e->field, l, FcTrue);
		/*
		 * Adjust any pointers into the value list as they no
		 * longer point to anything valid
		 */
		if (t)
		{
		    FcPatternElt    *thisElt = st[i].elt;
		    for (t = s->test, i = 0; t; t = t->next, i++)
		    {
			if (st[i].elt == thisElt)
			    st[i].value = 0;
		    }
		}
		break;
	    case FcOpPrepend:
		if (t)
		{
		    FcConfigAdd (&st[i].elt->values, st[i].value, FcFalse, l);
		    break;
		}
		/* fall through ... */
	    case FcOpPrependFirst:
		FcConfigPatternAdd (p, e->field, l, FcFalse);
		break;
	    case FcOpAppend:
		if (t)
		{
		    FcConfigAdd (&st[i].elt->values, st[i].value, FcTrue, l);
		    break;
		}
		/* fall through ... */
	    case FcOpAppendLast:
		FcConfigPatternAdd (p, e->field, l, FcTrue);
		break;
	    default:
		break;
	    }
	}
	/*
	 * Now go through the pattern and eliminate
	 * any properties without data
	 */
	for (e = s->edit; e; e = e->next)
	    FcConfigPatternCanon (p, e->field);

	if (FcDebug () & FC_DBG_EDIT)
	{
	    printf ("FcConfigSubstitute edit");
	    FcPatternPrint (p);
	}
    }
    FcMemFree (FC_MEM_SUBSTATE, config->maxObjects * sizeof (FcSubState));
    free (st);
    if (FcDebug () & FC_DBG_EDIT)
    {
	printf ("FcConfigSubstitute done");
	FcPatternPrint (p);
    }
    return FcTrue;
}

FcBool
FcConfigSubstitute (FcConfig	*config,
		    FcPattern	*p,
		    FcMatchKind	kind)
{
    return FcConfigSubstituteWithPat (config, p, 0, kind);
}

#if defined (_WIN32) && (defined (PIC) || defined (DLL_EXPORT))

static FcChar8 fontconfig_path[1000] = "";

BOOL WINAPI
DllMain (HINSTANCE hinstDLL,
	 DWORD     fdwReason,
	 LPVOID    lpvReserved)
{
  FcChar8 *p;

  switch (fdwReason) {
  case DLL_PROCESS_ATTACH:
      if (!GetModuleFileName ((HMODULE) hinstDLL, fontconfig_path,
			      sizeof (fontconfig_path)))
	  break;

      /* If the fontconfig DLL is in a "bin" or "lib" subfolder,
       * assume it's a Unix-style installation tree, and use
       * "etc/fonts" in there as FONTCONFIG_PATH. Otherwise use the
       * folder where the DLL is as FONTCONFIG_PATH.
       */
      p = strrchr (fontconfig_path, '\\');
      if (p)
      {
	  *p = '\0';
	  p = strrchr (fontconfig_path, '\\');
	  if (p && (FcStrCmpIgnoreCase (p + 1, "bin") == 0 ||
		    FcStrCmpIgnoreCase (p + 1, "lib") == 0))
	      *p = '\0';
	  strcat (fontconfig_path, "\\etc\\fonts");
      }
      else
          fontconfig_path[0] = '\0';
      
      break;
  }

  return TRUE;
}

#undef FONTCONFIG_PATH
#define FONTCONFIG_PATH fontconfig_path

#else /* !(_WIN32 && PIC) */

#endif /* !(_WIN32 && PIC) */

#ifndef FONTCONFIG_FILE
#define FONTCONFIG_FILE	"fonts.conf"
#endif

static FcChar8 *
FcConfigFileExists (const FcChar8 *dir, const FcChar8 *file)
{
    FcChar8    *path;

    if (!dir)
	dir = (FcChar8 *) "";
    path = malloc (strlen ((char *) dir) + 1 + strlen ((char *) file) + 1);
    if (!path)
	return 0;

    strcpy ((char *) path, (const char *) dir);
    /* make sure there's a single separator */
#if defined(_WIN32) || defined(__OS2__)
    if ((!path[0] || (path[strlen((char *) path)-1] != '/' &&
		      path[strlen((char *) path)-1] != '\\')) &&
	!(file[0] == '/' ||
	  file[0] == '\\' ||
	  (isalpha (file[0]) && file[1] == ':' && (file[2] == '/' || file[2] == '\\'))))
	strcat ((char *) path, "\\");
#else
    if ((!path[0] || path[strlen((char *) path)-1] != '/') && file[0] != '/')
	strcat ((char *) path, "/");
#endif
    strcat ((char *) path, (char *) file);

    FcMemAlloc (FC_MEM_STRING, strlen ((char *) path) + 1);
    if (access ((char *) path, R_OK) == 0)
	return path;
    
    FcStrFree (path);
    return 0;
}

static FcChar8 **
FcConfigGetPath (void)
{
    FcChar8    **path;
    FcChar8    *env, *e, *colon;
    FcChar8    *dir;
    int	    npath;
    int	    i;

    npath = 2;	/* default dir + null */
    env = (FcChar8 *) getenv ("FONTCONFIG_PATH");
    if (env)
    {
	e = env;
	npath++;
	while (*e)
	    if (*e++ == FC_SEARCH_PATH_SEPARATOR)
		npath++;
    }
    path = calloc (npath, sizeof (FcChar8 *));
    if (!path)
	goto bail0;
    i = 0;

    if (env)
    {
	e = env;
	while (*e) 
	{
	    colon = (FcChar8 *) strchr ((char *) e, FC_SEARCH_PATH_SEPARATOR);
	    if (!colon)
		colon = e + strlen ((char *) e);
	    path[i] = malloc (colon - e + 1);
	    if (!path[i])
		goto bail1;
	    strncpy ((char *) path[i], (const char *) e, colon - e);
	    path[i][colon - e] = '\0';
	    if (*colon)
		e = colon + 1;
	    else
		e = colon;
	    i++;
	}
    }

#ifdef __OS2__
    // Add the home folder!
    dir = (FcChar8 *) FcConfigHome();
#else
    dir = (FcChar8 *) FONTCONFIG_PATH;
#endif
    path[i] = malloc (strlen ((char *) dir) + 1);
    if (!path[i])
	goto bail1;
    strcpy ((char *) path[i], (const char *) dir);
    return path;

bail1:
    for (i = 0; path[i]; i++)
	free (path[i]);
    free (path);
bail0:
    return 0;
}

static void
FcConfigFreePath (FcChar8 **path)
{
    FcChar8    **p;

    for (p = path; *p; p++)
	free (*p);
    free (path);
}

static FcBool	_FcConfigHomeEnabled = FcTrue;

FcChar8 *
FcConfigHome (void)
{
    if (_FcConfigHomeEnabled)
    {
        char *home = getenv ("HOME");

#ifdef _WIN32
	if (home == NULL)
	    home = getenv ("USERPROFILE");
#endif
#ifdef __OS2__
        if (home == NULL)
	    home = getenv ("ETC");
#endif

	return home;
    }
    return 0;
}

FcBool
FcConfigEnableHome (FcBool enable)
{
    FcBool  prev = _FcConfigHomeEnabled;
    _FcConfigHomeEnabled = enable;
    return prev;
}

FcChar8 *
FcConfigFilename (const FcChar8 *url)
{
    FcChar8    *file, *dir, **path, **p;
    
    if (!url || !*url)
    {
	url = (FcChar8 *) getenv ("FONTCONFIG_FILE");
	if (!url)
          url = (FcChar8 *) FONTCONFIG_FILE;
    }
    file = 0;

#if defined(_WIN32) || defined(__OS2__)
    if (isalpha (*url) &&
	url[1] == ':' &&
	(url[2] == '/' || url[2] == '\\'))
	goto absolute_path;
#endif

    switch (*url) {
    case '~':
	dir = FcConfigHome ();
	if (dir)
	    file = FcConfigFileExists (dir, url + 1);
	else
	    file = 0;
	break;
#if defined(_WIN32) || defined(__OS2__)
    case '\\':
    absolute_path:
#endif
    case '/':
	file = FcConfigFileExists (0, url);
	break;
    default:
        path = FcConfigGetPath ();
	if (!path)
	    return 0;
	for (p = path; *p; p++)
	{
	    file = FcConfigFileExists (*p, url);
	    if (file)
		break;
	}
        FcConfigFreePath (path);
#if defined(__OS2__)
        if (!file)
        {
          // Config file not found!
          // Creating default config file then in home, and try again!
          FILE *hFile;
          char *pchHome = FcConfigHome();
          if (pchHome)
          {
            char *pchFullPath = malloc(strlen(pchHome)+strlen(FONTCONFIG_FILE)+10);
    
            if (pchFullPath)
            {
              if (pchHome[strlen(pchHome)-1]!='\\')
                sprintf(pchFullPath, "%s\\%s", pchHome, FONTCONFIG_FILE);
              else
                sprintf(pchFullPath, "%s%s", pchHome, FONTCONFIG_FILE);

              hFile = fopen(pchFullPath, "wt");
              free(pchFullPath);
              if (hFile)
              {
                fprintf(hFile, DEFAULT_OS2_CONFIG_FILE);
                fclose(hFile);

                // Show info on text screens
                fprintf(stderr, "WARNING: New config file has been created for FontConfig!\n");
                fprintf(stderr, "         A scanning of all system fonts will be needed,\n");
                fprintf(stderr, "         which may take some minutes!\n");
                fprintf(stderr, "         Please be patient!\n");

		// Also show info in window, if possible!
		// The MB_NONMODAL flag is missing from OpenWatcom's OS/2 header
		// files, so we define it here in case it's still missing:
#ifndef MB_NONMODAL
#define MB_NONMODAL 0x8000
#endif
                WinMessageBox(HWND_DESKTOP,
                              HWND_DESKTOP,
                              "New config file has been created for FontConfig!\n"
                              "A scanning of all system fonts will be needed,\n"
                              "which may take some minutes!\n"
                              "Please be patient!\n",
                              "First start of FontConfig",
                              0xca1f0,
                              MB_OK | MB_INFORMATION | MB_MOVEABLE | MB_NONMODAL);

                // Now that we put there the default config file, start again!
                path = FcConfigGetPath ();
                if (!path)
                    return 0;
                for (p = path; *p; p++)
                {
                    file = FcConfigFileExists (*p, url);
                    if (file)
                        break;
                }
                FcConfigFreePath (path);
              }
            }
          }
        }
#endif
	break;
    }
    return file;
}

/*
 * Manage the application-specific fonts
 */

FcBool
FcConfigAppFontAddFile (FcConfig    *config,
			const FcChar8  *file)
{
    FcFontSet	*set;
    FcStrSet	*subdirs;
    FcStrList	*sublist;
    FcChar8	*subdir;

    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return FcFalse;
    }

    subdirs = FcStrSetCreate ();
    if (!subdirs)
	return FcFalse;
    
    set = FcConfigGetFonts (config, FcSetApplication);
    if (!set)
    {
	set = FcFontSetCreate ();
	if (!set)
	{
	    FcStrSetDestroy (subdirs);
	    return FcFalse;
	}
	FcConfigSetFonts (config, set, FcSetApplication);
    }
	
    if (!FcFileScanConfig (set, subdirs, 0, config->blanks, file, FcFalse, config))
    {
	FcStrSetDestroy (subdirs);
	return FcFalse;
    }
    if ((sublist = FcStrListCreate (subdirs)))
    {
	while ((subdir = FcStrListNext (sublist)))
	{
	    FcConfigAppFontAddDir (config, subdir);
	}
	FcStrListDone (sublist);
    }
    return FcTrue;
}

FcBool
FcConfigAppFontAddDir (FcConfig	    *config,
		       const FcChar8   *dir)
{
    FcFontSet	*set;
    FcStrSet	*subdirs;
    FcStrList	*sublist;
    FcChar8	*subdir;
    
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return FcFalse;
    }
    subdirs = FcStrSetCreate ();
    if (!subdirs)
	return FcFalse;
    
    set = FcConfigGetFonts (config, FcSetApplication);
    if (!set)
    {
	set = FcFontSetCreate ();
	if (!set)
	{
	    FcStrSetDestroy (subdirs);
	    return FcFalse;
	}
	FcConfigSetFonts (config, set, FcSetApplication);
    }
    
    if (!FcDirScanConfig (set, subdirs, 0, config->blanks, dir, FcFalse, config))
    {
	FcStrSetDestroy (subdirs);
	return FcFalse;
    }
    if ((sublist = FcStrListCreate (subdirs)))
    {
	while ((subdir = FcStrListNext (sublist)))
	{
	    FcConfigAppFontAddDir (config, subdir);
	}
	FcStrListDone (sublist);
    }
    return FcTrue;
}

void
FcConfigAppFontClear (FcConfig	    *config)
{
    if (!config)
    {
	config = FcConfigGetCurrent ();
	if (!config)
	    return;
    }

    FcConfigSetFonts (config, 0, FcSetApplication);
}

/*
 * Manage filename-based font source selectors
 */

FcBool
FcConfigGlobAdd (FcConfig	*config,
		 const FcChar8  *glob,
		 FcBool		accept)
{
    FcStrSet	*set = accept ? config->acceptGlobs : config->rejectGlobs;

    return FcStrSetAdd (set, glob);
}

static FcBool
FcConfigGlobMatch (const FcChar8    *glob,
		   const FcChar8    *string)
{
    FcChar8	c;

    while ((c = *glob++)) 
    {
	switch (c) {
	case '*':
	    /* short circuit common case */
	    if (!*glob)
		return FcTrue;
	    /* short circuit another common case */
	    if (strchr ((char *) glob, '*') == 0)
		string += strlen ((char *) string) - strlen ((char *) glob);
	    while (*string)
	    {
		if (FcConfigGlobMatch (glob, string))
		    return FcTrue;
		string++;
	    }
	    return FcFalse;
	case '?':
	    if (*string++ == '\0')
		return FcFalse;
	    break;
	default:
	    if (*string++ != c)
		return FcFalse;
	    break;
	}
    }
    return *string == '\0';
}

static FcBool
FcConfigGlobsMatch (const FcStrSet	*globs,
		    const FcChar8	*string)
{
    int	i;

    for (i = 0; i < globs->num; i++)
	if (FcConfigGlobMatch (globs->strs[i], string))
	    return FcTrue;
    return FcFalse;
}

FcBool
FcConfigAcceptFilename (FcConfig	*config,
			const FcChar8	*filename)
{
    if (FcConfigGlobsMatch (config->acceptGlobs, filename))
	return FcTrue;
    if (FcConfigGlobsMatch (config->rejectGlobs, filename))
	return FcFalse;
    return FcTrue;
}

/*
 * Manage font-pattern based font source selectors
 */

FcBool
FcConfigPatternsAdd (FcConfig	*config,
		     FcPattern	*pattern,
		     FcBool	accept)
{
    FcFontSet	*set = accept ? config->acceptPatterns : config->rejectPatterns;

    return FcFontSetAdd (set, pattern);
}

static FcBool
FcConfigPatternsMatch (const FcFontSet	*patterns,
		       const FcPattern	*font)
{
    int i;
    
    for (i = 0; i < patterns->nfont; i++)
	if (FcListPatternMatchAny (patterns->fonts[i], font))
	    return FcTrue;
    return FcFalse;
}

FcBool
FcConfigAcceptFont (FcConfig	    *config,
		    const FcPattern *font)
{
    if (FcConfigPatternsMatch (config->acceptPatterns, font))
	return FcTrue;
    if (FcConfigPatternsMatch (config->rejectPatterns, font))
	return FcFalse;
    return FcTrue;
}
