
/*
 *  This file was generated by the SOM Compiler.
 *  Generated using:
 *     SOM incremental update: 2.24
 */


/* ***** BEGIN LICENSE BLOCK *****
 * Version: CDDL 1.0/LGPL 2.1
 *
 * The contents of this file are subject to the COMMON DEVELOPMENT AND
 * DISTRIBUTION LICENSE (CDDL) Version 1.0 (the "License"); you may not use
 * this file except in compliance with the License. You may obtain a copy of
 * the License at http://www.sun.com/cddl/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initial Developer of the Original Code is
 * Eugene Romanenko, netlabs.org.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the LGPL are applicable instead of those
 * above. If you wish to allow use of your version of this file only under the
 * terms of the LGPL, and not to allow others to use your version of this file
 * under the terms of the CDDL, indicate your decision by deleting the
 * provisions above and replace them with the notice and other provisions
 * required by the LGPL. If you do not delete the provisions above, a recipient
 * may use your version of this file under the terms of any one of the CDDL
 * or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using template emitter:
 *      SOM Emitter emitxtm: 2.23.1.9
 */

#ifndef SOM_Module_lujpeg_Source
#define SOM_Module_lujpeg_Source
#endif
#define LuJpegDocument_Class_Source

#include "lujpeg.xih"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include "jversion.h"

// jpeglib defines boolean as int while SOM defines it as unsigned char,
// work this around (note that you need to use jpeg_boolean in this source if
// you need to refer to the jpeglib's definition of it)
#define boolean jpeg_boolean
#include <jpeglib.h>
#undef boolean


void resample( Environment *ev,
               LuPixbuf *out, int out_x0, int out_y0, int out_x1, int out_y1,
               LuPixbuf *in, float in_x0, float in_y0, float in_x1, float in_y1 );

unsigned EXPENTRY LibMain( unsigned hmod, unsigned termination )
{
    if ( termination ) {
        /* DLL is detaching from process */
    } else {
        /* DLL is attaching to process */
    }
    return( 1 );
}


extern "C" LuDocument * EXPENTRY createObject()
{
    return new LuJpegDocument;
}

extern "C" char * EXPENTRY getSupportedExtensions()
{
    return "JPG;JPEG;JPE";
}

static LuSignature      lsig = { 0, 0, 2, (void *)"\xff\xd8" };
static LuSignatureList  lsl  = { 1, &lsig };
static LuSignatureCheck lsc  = { 1, &lsl };

// getSignatureCheck is optional
extern "C" LuSignatureCheck * EXPENTRY getSignatureCheck()
{
    return &lsc;
}

static char version[256];
extern "C" char * EXPENTRY getDescription()
{
   strcpy(version, "Jpeg plugin, based on IJG JPEG library ");
   strcat(version, JVERSION);
   return version;
}


struct JpegDocument
{
    LuPixbuf *pb;
    double width;
    double height;
};

struct lujpeg_error_mgr
{
    struct jpeg_error_mgr jem;
    jmp_buf setjmp_buffer;
};

METHODDEF(void) lujpeg_error_exit( j_common_ptr cinfo )
{
    lujpeg_error_mgr *err = (lujpeg_error_mgr *)cinfo->err;
    char buffer[ JMSG_LENGTH_MAX ];
    (*cinfo->err->format_message)( cinfo, buffer );
    fprintf( stderr, "JPEG decoding error:\n%s\n", buffer );
    longjmp( err->setjmp_buffer, 1 );
}



SOM_Scope boolean  SOMLINK loadFile(LuJpegDocument *somSelf,
                                     Environment *ev, string filename,
                                    string password, long* errorCode,
                                    string* error)
{
    if ( errorCode != NULL ) {
        *errorCode = LU_LDERR_NO_ERROR;
    }

    LuJpegDocumentData *somThis = LuJpegDocumentGetData(somSelf);
    JpegDocument *d = (JpegDocument *)somThis->data;

    FILE *infile = NULL;
    if ( ( infile = fopen( filename, "rb" ) ) == NULL ) {
        if ( errorCode != NULL ) {
            *errorCode = LU_LDERR_OPEN_ERROR;
        }
        return FALSE;
    }

    short bpp = getBpp( somSelf, ev );
    jpeg_decompress_struct cinfo;
    lujpeg_error_mgr ljerr;
    cinfo.err = jpeg_std_error( &ljerr.jem );
    ljerr.jem.error_exit = lujpeg_error_exit;
    if ( setjmp( ljerr.setjmp_buffer ) ) {
        // If we get here, the JPEG code has signaled an error.
        jpeg_destroy_decompress( &cinfo );
        fclose( infile );
        if ( errorCode != NULL ) {
            *errorCode = LU_LDERR_WRONG_FORMAT;
        }
        return FALSE;
    }

    jpeg_create_decompress( &cinfo );
    jpeg_stdio_src( &cinfo, infile );
    jpeg_read_header( &cinfo, TRUE );
    cinfo.out_color_space = JCS_RGB;
    jpeg_start_decompress( &cinfo );

    d->width = cinfo.output_width;
    d->height = cinfo.output_height;
    d->pb = new LuPixbuf( ev, cinfo.output_width, cinfo.output_height, bpp );

    int pixbuf_rowstride, pixbuf_height, pixbuf_width;
    char *pixbuf_data, *dst, *src;

    pixbuf_data = (char *)d->pb->getDataPtr( ev );
    pixbuf_width = d->pb->getWidth( ev );
    pixbuf_height = d->pb->getHeight( ev );
    pixbuf_rowstride = d->pb->getRowSize(ev );

    JSAMPARRAY buffer;
    int row_stride = cinfo.output_width * cinfo.output_components;
    buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

    int i, j;
    i = cinfo.output_height;
    while ( cinfo.output_scanline < cinfo.output_height )
    {
        i--;
        jpeg_read_scanlines( &cinfo, buffer, 1 );
        dst = pixbuf_data + ( i * pixbuf_rowstride );
        int len = pixbuf_width * bpp;
        for ( j = 0; j < len; j += bpp )
        {
            dst[ j ] = buffer[0][ j + 2 ];
            dst[ j + 1 ] = buffer[0][ j + 1 ];
            dst[ j + 2 ] = buffer[0][ j ];
        }
    }

    jpeg_finish_decompress( &cinfo );
    jpeg_destroy_decompress( &cinfo );
    fclose( infile );

    return TRUE;
}


SOM_Scope short  SOMLINK getBpp(LuJpegDocument *somSelf,  Environment *ev)
{
    return 3;
}


SOM_Scope boolean  SOMLINK isScalable(LuJpegDocument *somSelf,
                                       Environment *ev)
{
    return TRUE;
}

SOM_Scope long  SOMLINK getPageCount(LuJpegDocument *somSelf,
                                      Environment *ev)
{
    return 1;
}


SOM_Scope void  SOMLINK getPageSize(LuJpegDocument *somSelf,
                                     Environment *ev, long pagenum,
                                    double* width, double* height)
{
    LuJpegDocumentData *somThis = LuJpegDocumentGetData(somSelf);
    JpegDocument *d = (JpegDocument *)somThis->data;

    if ( width != NULL ) {
        *width = d->width;
    }
    if ( height != NULL ) {
        *height = d->height;
    }
}


SOM_Scope boolean  SOMLINK renderPageToPixbuf(LuJpegDocument *somSelf,
                                               Environment *ev,
                                              long pagenum, long src_x,
                                              long src_y, long src_width,
                                              long src_height,
                                              double scale, long rotation,
                                              LuPixbuf* pixbuf,
                                              long* errorCode,
                                              string* error)
{
    if ( errorCode != NULL ) {
        *errorCode = LU_RERR_NO_ERROR;
    }

    LuJpegDocumentData *somThis = LuJpegDocumentGetData(somSelf);
    JpegDocument *d = (JpegDocument *)somThis->data;

    //somPrintf( "src_x: %d  src_y: %d  src_width: %d  src_height: %d  scale: %f\n",
    //            src_x, src_y, src_width, src_height, scale );

    float real_src_x = (float)src_x / scale;
    float real_src_y = (float)src_y / scale;
    float real_src_width = (float)src_width / scale;
    float real_src_height = (float)src_height / scale;

    //somPrintf( "real_src_x: %f  real_src_y: %f  real_src_width: %f  real_src_height: %f\n",
    //            real_src_x, real_src_y, real_src_width, real_src_height );

    short bpp = getBpp( somSelf, ev );

    int pb_rowstride = d->pb->getRowSize( ev );
    int pb_width     = d->pb->getWidth( ev );
    int pb_height    = d->pb->getHeight( ev );
    char *pb_data    = (char *)d->pb->getDataPtr( ev );

    if ( scale == 1.0 )
    {
        int pixbuf_rowstride = pixbuf->getRowSize( ev );
        char *pixbuf_data = (char *)pixbuf->getDataPtr( ev );
        char *src, *dst;
        int i, y;
        for ( y = pb_height-(src_y+src_height), i = 0; i < src_height; y++, i++ )
        {
            src = pb_data + (y * pb_rowstride) + (src_x * bpp);
            dst = pixbuf_data + (i * pixbuf_rowstride);
            memcpy( dst, src, src_width * bpp );
        }
    }
    else
    {
        float y = (float)pb_height - ( real_src_y + real_src_height );
        resample( ev, pixbuf, 0, 0, src_width - 1, src_height - 1,
                  d->pb, real_src_x, y, real_src_width + real_src_x, real_src_height + y );
    }

    return TRUE;
}


SOM_Scope void SOMLINK somDefaultInit(LuJpegDocument *somSelf,
                                      som3InitCtrl* ctrl)
{
    LuJpegDocumentData *somThis;
    somInitCtrl globalCtrl;
    somBooleanVector myMask;
    LuJpegDocument_BeginInitializer_somDefaultInit;
    LuJpegDocument_Init_LuDocument_somDefaultInit(somSelf, ctrl);

    // local LuJpegDocument initialization code
    JpegDocument *d = new JpegDocument;
    memset( d, 0, sizeof( JpegDocument ) );
    somThis->data = d;
}


SOM_Scope void SOMLINK somDestruct(LuJpegDocument *somSelf, octet doFree,
                                   som3DestructCtrl* ctrl)
{
    LuJpegDocumentData *somThis;
    somDestructCtrl globalCtrl;
    somBooleanVector myMask;
    LuJpegDocument_BeginDestructor;

    // local LuJpegDocument deinitialization code
    JpegDocument *d = (JpegDocument *)somThis->data;
    if ( d->pb != NULL ) {
        delete d->pb;
    }
    delete d;
    // end of local LuJpegDocument deinitialization code

    LuJpegDocument_EndDestructor;
}


