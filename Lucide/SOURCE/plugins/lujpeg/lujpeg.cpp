
/*
 *  This file was generated by the SOM Compiler.
 *  Generated using:
 *     SOM incremental update: 2.24
 */


/* ***** BEGIN LICENSE BLOCK *****
 * Version: CDDL 1.0/LGPL 2.1
 *
 * The contents of this file are subject to the COMMON DEVELOPMENT AND
 * DISTRIBUTION LICENSE (CDDL) Version 1.0 (the "License"); you may not use
 * this file except in compliance with the License. You may obtain a copy of
 * the License at http://www.sun.com/cddl/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initial Developer of the Original Code is
 * Eugene Romanenko, netlabs.org.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the LGPL are applicable instead of those
 * above. If you wish to allow use of your version of this file only under the
 * terms of the LGPL, and not to allow others to use your version of this file
 * under the terms of the CDDL, indicate your decision by deleting the
 * provisions above and replace them with the notice and other provisions
 * required by the LGPL. If you do not delete the provisions above, a recipient
 * may use your version of this file under the terms of any one of the CDDL
 * or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */



/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using template emitter:
 *      SOM Emitter emitxtm: 2.23.1.9
 */

#ifndef SOM_Module_lujpeg_Source
#define SOM_Module_lujpeg_Source
#endif
#define LuJpegDocument_Class_Source

#include "lujpeg.xih"

#define HAVE_BOOLEAN

#include <stdio.h>
#include <string.h>
#include <setjmp.h>
#include <jpeglib.h>



unsigned _System LibMain( unsigned hmod, unsigned termination )
{
    if ( termination ) {
        /* DLL is detaching from process */
    } else {
        /* DLL is attaching to process */
    }
    return( 1 );
}

extern "C" LuDocument * _System createObject()
{
    return new LuJpegDocument;
}

extern "C" char * _System getSupportedExtensions()
{
    return "JPG;JPEG;JPE";
}

extern "C" char * _System getDescription()
{
    return "Jpeg plugin, based on IJG JPEG Library.";
}


struct JpegDocument
{
    LuPixbuf *pb;
    double width;
    double height;
};

struct lujpeg_error_mgr
{
    struct jpeg_error_mgr jem;
    jmp_buf setjmp_buffer;
};

METHODDEF(void) lujpeg_error_exit( j_common_ptr cinfo )
{
    lujpeg_error_mgr *err = (lujpeg_error_mgr *)cinfo->err;
    char buffer[ JMSG_LENGTH_MAX ];
    (*cinfo->err->format_message)( cinfo, buffer );
    fprintf( stderr, "JPEG decoding error:\n%s\n", buffer );
    longjmp( err->setjmp_buffer, 1 );
}


SOM_Scope boolean  SOMLINK loadFile(LuJpegDocument *somSelf,
                                     Environment *ev, string filename,
                                    string password, string* error)
{
    LuJpegDocumentData *somThis = LuJpegDocumentGetData(somSelf);
    JpegDocument *d = (JpegDocument *)somThis->data;

    FILE *infile = NULL;
    if ( ( infile = fopen( filename, "rb" ) ) == NULL ) {
        return FALSE;
    }

    short bpp = getBpp( somSelf, ev );
    jpeg_decompress_struct cinfo;
    lujpeg_error_mgr ljerr;
    cinfo.err = jpeg_std_error( &ljerr.jem );
    ljerr.jem.error_exit = lujpeg_error_exit;
    if ( setjmp( ljerr.setjmp_buffer ) ) {
        // If we get here, the JPEG code has signaled an error.
        jpeg_destroy_decompress( &cinfo );
        fclose( infile );
        return FALSE;
    }

    jpeg_create_decompress( &cinfo );
    jpeg_stdio_src( &cinfo, infile );
    jpeg_read_header( &cinfo, TRUE );
    cinfo.out_color_space = JCS_RGB;
    jpeg_start_decompress( &cinfo );

    d->width = cinfo.output_width;
    d->height = cinfo.output_height;
    d->pb = new LuPixbuf( ev, cinfo.output_width, cinfo.output_height, bpp );

    int pixbuf_rowstride, pixbuf_height, pixbuf_width;
    char *pixbuf_data, *dst, *src;

    pixbuf_data = (char *)d->pb->getDataPtr( ev );
    pixbuf_width = d->pb->getWidth( ev );
    pixbuf_height = d->pb->getHeight( ev );
    pixbuf_rowstride = d->pb->getRowSize(ev );

    JSAMPARRAY buffer;
    int row_stride = cinfo.output_width * cinfo.output_components;
    buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

    int i, j;
    i = cinfo.output_height;
    while ( cinfo.output_scanline < cinfo.output_height )
    {
        i--;
        jpeg_read_scanlines( &cinfo, buffer, 1 );
        dst = pixbuf_data + i * pixbuf_rowstride;
        for ( j = 0; j < pixbuf_rowstride; j += bpp )
        {
            dst[ j ] = buffer[0][ j + 2 ];
            dst[ j + 1 ] = buffer[0][ j + 1 ];
            dst[ j + 2 ] = buffer[0][ j ];
        }
    }

    jpeg_finish_decompress( &cinfo );
    jpeg_destroy_decompress( &cinfo );
    fclose( infile );

    return TRUE;
}


SOM_Scope short  SOMLINK getBpp(LuJpegDocument *somSelf,  Environment *ev)
{
    return 3;
}


SOM_Scope long  SOMLINK getPageCount(LuJpegDocument *somSelf,
                                      Environment *ev)
{
    return 1;
}


SOM_Scope void  SOMLINK getPageSize(LuJpegDocument *somSelf,
                                     Environment *ev, long pagenum,
                                    double* width, double* height)
{
    LuJpegDocumentData *somThis = LuJpegDocumentGetData(somSelf);
    JpegDocument *d = (JpegDocument *)somThis->data;

    if ( width != NULL ) {
        *width = d->width;
    }
    if ( height != NULL ) {
        *height = d->height;
    }
}


SOM_Scope void  SOMLINK renderPageToPixbuf(LuJpegDocument *somSelf,
                                            Environment *ev,
                                           long pagenum, long src_x,
                                           long src_y, long src_width,
                                           long src_height, double scale,
                                           long rotation, LuPixbuf* pixbuf)
{
    LuJpegDocumentData *somThis = LuJpegDocumentGetData(somSelf);
    JpegDocument *d = (JpegDocument *)somThis->data;

    //somPrintf( "src_x: %d  src_y: %d  src_width: %d  src_height: %d\n",
    //            src_x, src_y, src_width, src_height );

    short bpp = getBpp( somSelf, ev );
    int pb_rowstride = d->pb->getRowSize( ev );
    int pb_height = d->pb->getHeight( ev );
    int pixbuf_rowstride = pixbuf->getRowSize( ev );
    char *pb_data = (char *)d->pb->getDataPtr( ev );
    char *pixbuf_data = (char *)pixbuf->getDataPtr( ev );
    char *src, *dst;
    int i, y;
    for ( y = pb_height-(src_y+src_height), i = 0; i < src_height; y++, i++ )
    {
        src = pb_data + (y * pb_rowstride) + (src_x * bpp);
        dst = pixbuf_data + (i * pixbuf_rowstride);
        memcpy( dst, src, src_width * bpp );
    }
}


SOM_Scope void SOMLINK somDefaultInit(LuJpegDocument *somSelf,
                                      som3InitCtrl* ctrl)
{
    LuJpegDocumentData *somThis;
    somInitCtrl globalCtrl;
    somBooleanVector myMask;
    LuJpegDocument_BeginInitializer_somDefaultInit;
    LuJpegDocument_Init_LuDocument_somDefaultInit(somSelf, ctrl);

    // local LuJpegDocument initialization code
    JpegDocument *d = new JpegDocument;
    memset( d, 0, sizeof( JpegDocument ) );
    somThis->data = d;
}


SOM_Scope void SOMLINK somDestruct(LuJpegDocument *somSelf, octet doFree,
                                   som3DestructCtrl* ctrl)
{
    LuJpegDocumentData *somThis;
    somDestructCtrl globalCtrl;
    somBooleanVector myMask;
    LuJpegDocument_BeginDestructor;

    // local LuJpegDocument deinitialization code
    JpegDocument *d = (JpegDocument *)somThis->data;
    if ( d->pb != NULL ) {
        delete d->pb;
    }
    delete d;
    // end of local LuJpegDocument deinitialization code

    LuJpegDocument_EndDestructor;
}


