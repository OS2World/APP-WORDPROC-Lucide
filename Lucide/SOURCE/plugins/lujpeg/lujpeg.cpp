/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using template emitter:
 *      SOM Emitter emitxtm: 2.23.1.9
 */

#ifndef SOM_Module_lujpeg_Source
#define SOM_Module_lujpeg_Source
#endif
#define LuJpegDocument_Class_Source

#include "lujpeg.xih"

#define HAVE_BOOLEAN

#include <stdio.h>
#include <string.h>
#include <jpeglib.h>


unsigned _System LibMain( unsigned hmod, unsigned termination )
{
    if ( termination ) {
        /* DLL is detaching from process */
    } else {
        /* DLL is attaching to process */
    }
    return( 1 );
}

extern "C" LuDocument * _System createObject()
{
    return new LuJpegDocument;
}

extern "C" char * _System getSupportedExtensions()
{
    return "JPG;JPEG;JPE";
}

extern "C" char * _System getDescription()
{
    return "Jpeg plugin, based on IJG JPEG Library.";
}


struct JpegDocument
{
    LuPixbuf *pb;
    double width;
    double height;
};


SOM_Scope boolean  SOMLINK loadFile(LuJpegDocument *somSelf,
                                     Environment *ev, string filename,
                                    string password, string* error)
{
    LuJpegDocumentData *somThis = LuJpegDocumentGetData(somSelf);
    JpegDocument *d = (JpegDocument *)somThis->data;

    FILE *infile = NULL;
    if ( ( infile = fopen( filename, "rb" ) ) == NULL ) {
        return FALSE;
    }

    jpeg_decompress_struct cinfo;
    jpeg_error_mgr jerr;
    cinfo.err = jpeg_std_error( &jerr );
    jpeg_create_decompress( &cinfo );
    jpeg_stdio_src( &cinfo, infile );
    jpeg_read_header( &cinfo, TRUE );
    cinfo.out_color_space = JCS_RGB;
    jpeg_start_decompress( &cinfo );

    d->width = cinfo.output_width;
    d->height = cinfo.output_height;
    d->pb = new LuPixbuf( ev, cinfo.output_width, cinfo.output_height );

    int pixbuf_rowstride, pixbuf_height, pixbuf_width;
    char *pixbuf_data, *dst, *src;

    pixbuf_data = (char *)d->pb->getDataPtr( ev );
    pixbuf_width = d->pb->getWidth( ev );
    pixbuf_height = d->pb->getHeight( ev );
    pixbuf_rowstride = d->pb->getRowSize(ev );

    JSAMPARRAY buffer;
    int row_stride = cinfo.output_width * cinfo.output_components;
    buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

    int i, j;
    i = cinfo.output_height;
    while ( cinfo.output_scanline < cinfo.output_height )
    {
        i--;
        jpeg_read_scanlines( &cinfo, buffer, 1 );
        dst = pixbuf_data + i * pixbuf_rowstride;
        for ( j = 0; j < pixbuf_rowstride; j += 3 )
        {
            dst[ j ] = buffer[0][ j + 2 ];
            dst[ j + 1 ] = buffer[0][ j + 1 ];
            dst[ j + 2 ] = buffer[0][ j ];
        }
    }

    jpeg_finish_decompress( &cinfo );
    jpeg_destroy_decompress( &cinfo );
    fclose( infile );

    return TRUE;
}

SOM_Scope long  SOMLINK getPageCount(LuJpegDocument *somSelf,
                                      Environment *ev)
{
    return 1;
}

SOM_Scope void  SOMLINK getPageSize(LuJpegDocument *somSelf,
                                     Environment *ev, long pagenum,
                                    double* width, double* height)
{
    LuJpegDocumentData *somThis = LuJpegDocumentGetData(somSelf);
    JpegDocument *d = (JpegDocument *)somThis->data;

    if ( width != NULL ) {
        *width = d->width;
    }
    if ( height != NULL ) {
        *height = d->height;
    }
}

SOM_Scope void  SOMLINK renderPageToPixbuf(LuJpegDocument *somSelf,
                                            Environment *ev,
                                           long pagenum, long src_x,
                                           long src_y, long src_width,
                                           long src_height, double scale,
                                           long rotation, LuPixbuf* pixbuf)
{
    LuJpegDocumentData *somThis = LuJpegDocumentGetData(somSelf);
    JpegDocument *d = (JpegDocument *)somThis->data;

    //somPrintf( "src_x: %d  src_y: %d  src_width: %d  src_height: %d\n",
    //            src_x, src_y, src_width, src_height );

    int pb_rowstride = d->pb->getRowSize( ev );
    int pb_height = d->pb->getHeight( ev );
    int pixbuf_rowstride = pixbuf->getRowSize( ev );
    char *pb_data = (char *)d->pb->getDataPtr( ev );
    char *pixbuf_data = (char *)pixbuf->getDataPtr( ev );
    char *src, *dst;
    int i, y;
    for ( y = pb_height-(src_y+src_height), i = 0; i < src_height; y++, i++ )
    {
        src = pb_data + (y * pb_rowstride) + (src_x*3);
        dst = pixbuf_data + (i * pixbuf_rowstride);
        memcpy( dst, src, src_width * 3 );
    }
    //long len = __min( pixbuf->getDataLen(ev), d->pb->getDataLen(ev) );
    //memcpy( pixbuf->getDataPtr(ev), d->pb->getDataPtr(ev), len );
}

SOM_Scope void SOMLINK somDefaultInit(LuJpegDocument *somSelf,
                                      som3InitCtrl* ctrl)
{
    LuJpegDocumentData *somThis;
    somInitCtrl globalCtrl;
    somBooleanVector myMask;
    LuJpegDocument_BeginInitializer_somDefaultInit;
    LuJpegDocument_Init_LuDocument_somDefaultInit(somSelf, ctrl);

    // local LuJpegDocument initialization code
    JpegDocument *d = new JpegDocument;
    memset( d, 0, sizeof( JpegDocument ) );
    somThis->data = d;
}


SOM_Scope void SOMLINK somDestruct(LuJpegDocument *somSelf, octet doFree,
                                   som3DestructCtrl* ctrl)
{
    LuJpegDocumentData *somThis;
    somDestructCtrl globalCtrl;
    somBooleanVector myMask;
    LuJpegDocument_BeginDestructor;

    // local LuJpegDocument deinitialization code
    JpegDocument *d = (JpegDocument *)somThis->data;
    if ( d->pb != NULL ) {
	    delete d->pb;
	}
    delete d;
    // end of local LuJpegDocument deinitialization code

    LuJpegDocument_EndDestructor;
}


