
/*
 *  This file was generated by the SOM Compiler.
 *  Generated using:
 *     SOM incremental update: 2.24
 */


/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using template emitter:
 *      SOM Emitter emitxtm: 2.23.1.9
 */

#ifndef SOM_Module_lupoppler_Source
#define SOM_Module_lupoppler_Source
#endif
#define LuPopplerDocument_Class_Source

#include "lupoppler.xih"

#include <goo\GooString.h>
#include <goo\GooList.h>
#include <splash\SplashBitmap.h>
#include <UGooString.h>
#include <GlobalParams.h>
#include <ErrorCodes.h>
#include <PDFDoc.h>
#include <SplashOutputDev.h>
#include <TextOutputDev.h>
#include <PSOutputDev.h>
#include <FontInfo.h>
#include <Outline.h>
#include <UnicodeMap.h>
#include <Gfx.h>
#include <Link.h>

#define INCL_DOS
#include <os2.h>

#include <vector>
using namespace std;
#include <time.h>
#include "cpconv.h"

typedef vector<LuRectangle> RectList;


unsigned _System LibMain( unsigned hmod, unsigned termination )
{
    if ( termination ) {
        /* DLL is detaching from process */
    } else {
        /* DLL is attaching to process */
    }
    return( 1 );
}


extern "C" LuDocument * _System createObject()
{
    return new LuPopplerDocument;
}

extern "C" char * _System getSupportedExtensions()
{
    return "PDF";
}

extern "C" char * _System getDescription()
{
    return "PDF plugin, based on poppler library.";
}


class PopplerPage
{
    public:

        Page *page;
        TextOutputDev *text_dev;
        Gfx *gfx;

        PopplerPage();
        ~PopplerPage();
};

PopplerPage::PopplerPage()
{
    page = NULL;
    text_dev = NULL;
    gfx = NULL;
}

PopplerPage::~PopplerPage()
{
    delete text_dev;
    delete gfx;
}


class PopplerDocument
{
    public:

        PDFDoc *doc;
        SplashOutputDev *output_dev;
        PopplerPage *pages;
        char *text;
        HMTX mutex;

        PopplerDocument();
        ~PopplerDocument();
};

PopplerDocument::PopplerDocument()
{
    doc        = NULL;
    output_dev = NULL;
    pages      = NULL;
    text       = NULL;
    mutex      = NULLHANDLE;
    DosCreateMutexSem( NULL, &mutex, 0, FALSE );
}

PopplerDocument::~PopplerDocument()
{
    delete [] pages;
    delete doc;
    delete output_dev;
    delete text;
    DosCloseMutexSem( mutex );
}


static char *newstrdup( const char *s )
{
    if ( s == NULL ) {
        return NULL;
    }
    char *temp = new char[ strlen( s ) + 1 ];
    strcpy( temp, s );
    return temp;
}

static char *somstrdup( const char *s )
{
    if ( s == NULL ) {
        return NULL;
    }
    char *temp = (char *)SOMMalloc( strlen( s ) + 1 );
    strcpy( temp, s );
    return temp;
}


SOM_Scope short  SOMLINK getBpp(LuPopplerDocument *somSelf,  Environment *ev)
{
    return 4;
}

SOM_Scope boolean  SOMLINK isScalable(LuPopplerDocument *somSelf,
                                       Environment *ev)
{
    return TRUE;
}


SOM_Scope boolean  SOMLINK isRotable(LuPopplerDocument *somSelf,
                                      Environment *ev)
{
    return TRUE;
}


SOM_Scope long  SOMLINK getPageCount(LuPopplerDocument *somSelf,
                                      Environment *ev)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    return ((PopplerDocument *)somThis->data)->doc->getNumPages();
}


SOM_Scope void  SOMLINK getPageSize(LuPopplerDocument *somSelf,
                                    Environment *ev, long pagenum,
                                    double* width, double* height)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);

    Page *page = ((PopplerDocument *)somThis->data)->pages[ pagenum ].page;

    double page_width, page_height;
    int rotate = page->getRotate();
    if ( rotate == 90 || rotate == 270 ) {
        page_height = page->getCropWidth();
        page_width = page->getCropHeight();
    } else {
        page_width = page->getCropWidth();
        page_height = page->getCropHeight();
    }

    if ( width != NULL ) {
        *width = page_width;
    }
    if ( height != NULL ) {
        *height = page_height;
    }
}


static void copy_page_to_pixbuf( Environment *ev, SplashBitmap *bitmap, LuPixbuf *pixbuf )
{
    int splash_width, splash_height, splash_rowstride;
    int pixbuf_rowstride, pixbuf_height, pixbuf_width;
    int height, width, rowstride;
    char *pixbuf_data, *dst, *src;

    SplashColorPtr color_ptr = bitmap->getDataPtr();

    splash_width = bitmap->getWidth();
    splash_height = bitmap->getHeight();
    splash_rowstride = bitmap->getRowSize();

    //printf( "splash_width: %d   splash_height: %d   splash_rowstride: %d\n",
    //            splash_width, splash_height, splash_rowstride );

    pixbuf_data = (char *)pixbuf->getDataPtr( ev );
    pixbuf_width = pixbuf->getWidth( ev );
    pixbuf_height = pixbuf->getHeight( ev );
    pixbuf_rowstride = pixbuf->getRowSize(ev );

    width = __min( splash_width, pixbuf_width );
    height = __min( splash_height, pixbuf_height );
    rowstride = __min( splash_rowstride, pixbuf_rowstride );

    int i, j;
    for ( i = 0, j = ( height - 1 ); i < height; i++, j-- )
    {
        dst = pixbuf_data + i * pixbuf_rowstride;
        src = ((char *)color_ptr) + j * splash_rowstride;
        memcpy( dst, src, rowstride );
    }

    // test
    //memcpy( pixbuf_data, color_ptr, pixbuf->getDataLen( ev ) );
}


SOM_Scope void  SOMLINK renderPageToPixbuf(LuPopplerDocument *somSelf,
                                            Environment *ev,
                                           long pagenum, long src_x,
                                           long src_y, long src_width,
                                           long src_height, double scale,
                                           long rotation, LuPixbuf* pixbuf)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PopplerDocument *document = (PopplerDocument *)somThis->data;
    Page *page = document->pages[ pagenum ].page;

    if ( ( scale < 0.0 ) || ( pixbuf == NULL ) ) {
        return;
    }

    DosRequestMutexSem( document->mutex, SEM_INDEFINITE_WAIT );
    page->displaySlice( document->output_dev,
                72.0 * scale, 72.0 * scale,
                rotation,
                gFalse, /* useMediaBox */
                gTrue, /* Crop */
                src_x, src_y,
                src_width, src_height,
                NULL, /* links */
                document->doc->getCatalog() );
    DosReleaseMutexSem( document->mutex );

    copy_page_to_pixbuf( ev, document->output_dev->getBitmap(), pixbuf );
}


SOM_Scope boolean  SOMLINK isAsynchRenderingSupported(LuPopplerDocument *somSelf,
                                                       Environment *ev)
{
    return TRUE;
}


struct asynchCallbackData
{
    Environment      *ev;
    LuPixbuf         *pixbuf;
    SplashBitmap     *bitmap;
    void             *fndata;
    _asynchCallbackFn fnd;
    _asynchCallbackFn fna;
    long              tmr;
    bool              forceDraw;
    long              delay;
};

static GBool abortCheckCbk( void *data )
{
    long now;
    asynchCallbackData *cd = (asynchCallbackData *)data;
    DosQuerySysInfo( QSV_MS_COUNT, QSV_MS_COUNT, &now, sizeof( long ) );
    long dist = ( now - cd->tmr );
    if ( ( dist > cd->delay ) || cd->forceDraw ) {
        copy_page_to_pixbuf( cd->ev, cd->bitmap, cd->pixbuf );
        cd->fnd( cd->fndata );
        cd->tmr = now;
        cd->delay += 100;
    }
    return (GBool)cd->fna( cd->fndata );
}

SOM_Scope void  SOMLINK renderPageToPixbufAsynch(LuPopplerDocument *somSelf,
                                                  Environment *ev,
                                                 long pagenum,
                                                 long src_x,
                                                 long src_y,
                                                 long src_width,
                                                 long src_height,
                                                 double scale,
                                                 long rotation,
                                                 LuPixbuf* pixbuf,
                                                 LuDocument_asynchCallbackFn fnd,
                                                 LuDocument_asynchCallbackFn fna,
                                                 somToken fndata)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PopplerDocument *document = (PopplerDocument *)somThis->data;
    Page *page = document->pages[ pagenum ].page;

    if ( ( scale < 0.0 ) || ( pixbuf == NULL ) ) {
        return;
    }

    asynchCallbackData acd;
    acd.ev        = ev;
    acd.pixbuf    = pixbuf;
    acd.bitmap    = document->output_dev->getBitmap();
    acd.fndata    = fndata;
    acd.fnd       = (_asynchCallbackFn)fnd;
    acd.fna       = (_asynchCallbackFn)fna;
    acd.forceDraw = false;
    acd.delay     = 100;
    DosQuerySysInfo( QSV_MS_COUNT, QSV_MS_COUNT, &acd.tmr, sizeof( long ) );

    DosRequestMutexSem( document->mutex, SEM_INDEFINITE_WAIT );
    page->displaySlice( document->output_dev,
                72.0 * scale, 72.0 * scale,
                rotation,
                gFalse, /* useMediaBox */
                gTrue, /* Crop */
                src_x, src_y,
                src_width, src_height,
                NULL, /* links */
                document->doc->getCatalog(),
                abortCheckCbk, &acd );
    DosReleaseMutexSem( document->mutex );

    acd.forceDraw = true;
    abortCheckCbk( &acd );
}

static TextOutputDev *get_text_output_dev( PopplerPage *page,
                                           PopplerDocument *document )
{
    if ( page->text_dev == NULL )
    {
        DosRequestMutexSem( document->mutex, SEM_INDEFINITE_WAIT );
        page->text_dev = new TextOutputDev( NULL, gTrue, gFalse, gFalse );

        page->gfx = page->page->createGfx(page->text_dev,
                          72.0, 72.0, 0,
                          gFalse, /* useMediaBox */
                          gTrue, /* Crop */
                          -1, -1, -1, -1,
                          NULL, /* links */
                          document->doc->getCatalog(),
                          NULL, NULL, NULL, NULL);

        page->page->display( page->gfx );
        page->text_dev->endPage();
        DosReleaseMutexSem( document->mutex );
    }

    return page->text_dev;
}


SOM_Scope LuDocument_LuRectSequence*  SOMLINK getSelectionRectangles(LuPopplerDocument *somSelf,
                                                                    Environment *ev,
                                                                   long pagenum,
                                                                   double scale,
                                                                   LuRectangle* selection)
{
    LuDocument_LuRectSequence *rectangles = NULL;

    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PopplerDocument *document = (PopplerDocument *)somThis->data;
    PopplerPage *page = &( document->pages[ pagenum ] );

    TextOutputDev *text_dev = get_text_output_dev( page, document );

    PDFRectangle poppler_selection;
    poppler_selection.x1 = selection->x1;
    poppler_selection.y1 = selection->y1;
    poppler_selection.x2 = selection->x2;
    poppler_selection.y2 = selection->y2;

    GooList *list = text_dev->getSelectionRegion( &poppler_selection, scale );
    int len = list->getLength();

    if ( len > 0 )
    {
        rectangles = (LuDocument_LuRectSequence *)SOMMalloc( sizeof( LuDocument_LuRectSequence ) );
        rectangles->_maximum = len;
        rectangles->_length = len;
        rectangles->_buffer = (LuRectangle *)SOMMalloc( sizeof( LuRectangle ) * len );

        for ( int i = 0; i < len; i++ )
        {
            PDFRectangle *selection_rect = (PDFRectangle *)list->get( i );
            rectangles->_buffer[ i ].x1 = selection_rect->x1;
            rectangles->_buffer[ i ].y1 = selection_rect->y1;
            rectangles->_buffer[ i ].x2 = selection_rect->x2;
            rectangles->_buffer[ i ].y2 = selection_rect->y2;
            delete selection_rect;
        }
    }
    delete list;

    return rectangles;
}


SOM_Scope boolean  SOMLINK isHaveText(LuPopplerDocument *somSelf,
                                      Environment *ev)
{
    return TRUE;
}


SOM_Scope string  SOMLINK getText(LuPopplerDocument *somSelf,
                                   Environment *ev, long pagenum,
                                  LuRectangle* selection)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);

    if ( selection == NULL ) {
        return NULL;
    }

    PopplerDocument *document = (PopplerDocument *)somThis->data;
    PopplerPage *page = &( document->pages[ pagenum ] );

    TextOutputDev *text_dev = get_text_output_dev( page, document );

    GooString *sel_text = new GooString;
    char *result;
    PDFRectangle pdf_selection;

    pdf_selection.x1 = selection->x1;
    pdf_selection.y1 = selection->y1;
    pdf_selection.x2 = selection->x2;
    pdf_selection.y2 = selection->y2;

    DosRequestMutexSem( document->mutex, SEM_INDEFINITE_WAIT );
    sel_text = text_dev->getSelectionText( &pdf_selection );

    delete document->text;
    document->text = newstrdup( sel_text->getCString() );
    delete sel_text;
    DosReleaseMutexSem( document->mutex );

    return document->text;
}


SOM_Scope boolean  SOMLINK isHaveLinks(LuPopplerDocument *somSelf,
                                        Environment *ev)
{
    return TRUE;
}


static long find_dest_page( PDFDoc *doc, LinkDest *link_dest )
{
    long page_num = 0;

    if ( link_dest == NULL ) {
        return page_num;
    }

    if ( link_dest->isPageRef() )
    {
        Ref page_ref = link_dest->getPageRef();
        page_num = doc->findPage( page_ref.num, page_ref.gen ) - 1;
    }
    else {
        page_num = link_dest->getPageNum() - 1;
    }

    return page_num;
}

static void build_goto_dest( PDFDoc *doc, LuLink *evlink, LinkGoTo *link )
{
    LinkDest *link_dest;
    UGooString *named_dest;

    if ( !link->isOk() ) {
        return;
    }

    link_dest = link->getDest();
    named_dest = link->getNamedDest();

    if ( link_dest != NULL ) {
        evlink->page = find_dest_page( doc, link_dest );
    } else if ( named_dest != NULL ) {
        link_dest = doc->findDest( named_dest );
        evlink->page = find_dest_page( doc, link_dest );
        delete link_dest;
    } else {
        evlink->page = 0;
    }
}

static void build_link( PDFDoc *doc, LuLink *evlink,
                        const char *title, LinkAction *link_action )
{
    evlink->title = somstrdup( title );
    evlink->uri = NULL;
    evlink->type = LU_LINK_TYPE_TITLE;
    evlink->page = 0;

    if ( link_action == NULL ) {
        return;
    }

    switch ( link_action->getKind() )
    {
        case actionGoTo:
            {
                evlink->type = LU_LINK_TYPE_PAGE;
                LinkGoTo *lgt = dynamic_cast <LinkGoTo *> (link_action);
                build_goto_dest( doc, evlink, lgt );
            }
            break;

        case actionURI:
            {
                evlink->type = LU_LINK_TYPE_EXTERNAL_URI;
                LinkURI *lu = dynamic_cast <LinkURI *> (link_action);
                char *uri = lu->getURI()->getCString();
                if ( uri != NULL ) {
                    evlink->uri = somstrdup( uri );
                }
            }
            break;
    }
}

SOM_Scope LuDocument_LuLinkMapSequence*  SOMLINK getLinkMapping(LuPopplerDocument *somSelf,
                                                                 Environment *ev,
                                                                long pagenum)
{
    LuDocument_LuLinkMapSequence *mapping = NULL;

    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PopplerDocument *document = (PopplerDocument *)somThis->data;
    PopplerPage *page = &( document->pages[ pagenum ] );

    Object obj;
    Links *links = new Links( page->page->getAnnots( &obj ),
                            document->doc->getCatalog()->getBaseURI() );
    obj.free();

    if ( links == NULL ) {
        return NULL;
    }

    double height = 0;
    getPageSize( somSelf, ev, pagenum, NULL, &height );

    int len = links->getNumLinks();

    if ( len > 0 )
    {
        mapping = (LuDocument_LuLinkMapSequence *)SOMMalloc( sizeof( LuDocument_LuLinkMapSequence ) );
        mapping->_maximum = len;
        mapping->_length = len;
        mapping->_buffer = (LuLinkMapping *)SOMMalloc( sizeof( LuLinkMapping ) * len );

        for ( int i = 0; i < len; i++ )
        {
            Link *link = links->getLink( i );
            LinkAction *link_action = link->getAction();
            build_link( document->doc, &(mapping->_buffer[ i ].link), NULL, link_action );

            link->getRect( &(mapping->_buffer[ i ].area.x1),
                           &(mapping->_buffer[ i ].area.y1),
                           &(mapping->_buffer[ i ].area.x2),
                           &(mapping->_buffer[ i ].area.y2) );

            mapping->_buffer[ i ].area.x1 -= page->page->getCropBox()->x1;
            mapping->_buffer[ i ].area.x2 -= page->page->getCropBox()->x1;
            mapping->_buffer[ i ].area.y1 -= page->page->getCropBox()->y1;
            mapping->_buffer[ i ].area.y2 -= page->page->getCropBox()->y1;

            double y1 = mapping->_buffer[ i ].area.y1;
            double y2 = mapping->_buffer[ i ].area.y2;
            mapping->_buffer[ i ].area.y1 = height - y2;
            mapping->_buffer[ i ].area.y2 = height - y1;
        }
    }

    return mapping;
}


SOM_Scope boolean  SOMLINK isSaveable(LuPopplerDocument *somSelf,
                                       Environment *ev)
{
    return TRUE;
}


SOM_Scope boolean  SOMLINK saveAs(LuPopplerDocument *somSelf,
                                   Environment *ev, string filename)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PopplerDocument *document = (PopplerDocument *)somThis->data;

    boolean retval = FALSE;

    if ( filename != NULL ) {
        retval = document->doc->saveAs( new GooString( filename ) );
    }

    return retval;
}


SOM_Scope boolean  SOMLINK isPSExportable(LuPopplerDocument *somSelf,
                                           Environment *ev)
{
    return TRUE;
}


SOM_Scope void  SOMLINK exportToPS(LuPopplerDocument *somSelf,
                                    Environment *ev, string filename,
                                   long first_page, long last_page,
                                   double width, double height,
                                   boolean duplex)
{
    if ( filename == NULL ) {
        return;
    }
    if ( last_page < first_page ) {
        return;
    }

    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PDFDoc *doc = ((PopplerDocument *)somThis->data)->doc;


    PSOutputDev *out = new PSOutputDev( filename, doc->getXRef(),
                                        doc->getCatalog(),
                                        first_page + 1, last_page + 1,
                                        psModePS, (int)width, (int)height,
                                        duplex, 0, 0, 0, 0, gFalse );


    for ( long i = first_page; i < last_page; i++ ) {
        doc->displayPage( out, i + 1, 72.0, 72.0, 0, gFalse, gTrue, gFalse );
    }

    delete out;
}


SOM_Scope boolean  SOMLINK isHaveFontInfo(LuPopplerDocument *somSelf,
                                           Environment *ev)
{
    return TRUE;
}


SOM_Scope LuDocument_LuFontInfoSequence*  SOMLINK getFontInfo(LuPopplerDocument *somSelf,
                                                               Environment *ev)
{
    LuDocument_LuFontInfoSequence *fonts = NULL;

    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PopplerDocument *document = (PopplerDocument *)somThis->data;
    PDFDoc *doc = document->doc;

    DosRequestMutexSem( document->mutex, SEM_INDEFINITE_WAIT );
    FontInfoScanner *scanner = new FontInfoScanner( doc );
    GooList *items = scanner->scan( doc->getNumPages() );
    delete scanner;
    DosReleaseMutexSem( document->mutex );

    if ( items == NULL ) {
        return NULL;
    }

    int len = items->getLength();

    if ( len == 0 ) {
        delete items;
        return NULL;
    }

    fonts = (LuDocument_LuFontInfoSequence *)SOMMalloc( sizeof( LuDocument_LuFontInfoSequence ) );
    fonts->_maximum = len;
    fonts->_length = len;
    fonts->_buffer = (LuFontInfo *)SOMMalloc( sizeof( LuFontInfo ) * len );

    for ( int i = 0; i < len; i++ )
    {
        fonts->_buffer[i].name = NULL;
        fonts->_buffer[i].type = NULL;
        fonts->_buffer[i].embedded = NULL;

        FontInfo *info = (FontInfo *)items->get( i );

        // name
        GooString *gnm = info->getName();
        if ( gnm != NULL )
        {
            char *nm = gnm->getCString();
            if ( info->getSubset() && ( nm != NULL ) )
            {
                while ( *nm && ( *nm != '+' ) ) {
                    nm++;
                }
                if ( *nm ) {
                    nm++;
                }
            }
            if ( nm != NULL ) {
                if ( *nm ) {
                    fonts->_buffer[i].name = somstrdup( nm );
                }
            }
        }

        // type
        char *t = "Unknown font type";
        switch ( info->getType() )
        {
            case FontInfo::Type1:        t = "Type 1";          break;
            case FontInfo::Type1C:       t = "Type 1C";         break;
            case FontInfo::Type3:        t = "Type 3";          break;
            case FontInfo::TrueType:     t = "TrueType";        break;
            case FontInfo::CIDType0:     t = "Type 1 (CID)";    break;
            case FontInfo::CIDType0C:    t = "Type 1C (CID)";   break;
            case FontInfo::CIDTrueType:  t = "TrueType (CID)";  break;
        }
        fonts->_buffer[i].type = somstrdup( t );

        // embedded
        char *e = NULL;
        if ( info->getEmbedded() ) {
            if ( info->getSubset() ) {
                e = "Embedded subset";
            } else {
                e = "Embedded";
            }
        } else {
            e = "Not embedded";
        }
        fonts->_buffer[i].embedded = somstrdup( e );

    }

    return fonts;
}


SOM_Scope boolean  SOMLINK isHaveIndex(LuPopplerDocument *somSelf,
                                        Environment *ev)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PDFDoc *doc = ((PopplerDocument *)somThis->data)->doc;

    Outline *outline = doc->getOutline();
    if ( outline == NULL ) {
        return FALSE;
    }

    GooList *items = outline->getItems();
    if ( items == NULL ) {
        return FALSE;
    }

    return TRUE;
}

static char *unicode_to_char( Unicode *unicode, int len )
{
    static UnicodeMap *uMap = NULL;
    if ( uMap == NULL )
    {
        GooString *enc = new GooString( "UTF-8" );
        uMap = globalParams->getUnicodeMap( enc );
        uMap->incRefCnt();
        delete enc;
    }

    GooString gstr;
    char buf[8]; // 8 is enough for mapping an unicode char to a string
    int i, n;

    for ( i = 0; i < len; ++i ) {
        n = uMap->mapUnicode( unicode[i], buf, sizeof( buf ) );
        gstr.append( buf, n );
    }

    return newstrdup( gstr.getCString() );
}

static char *newstrFromUTF8( const char *s )
{
    unsigned blen = strlen( s ) + 1;
    char *b = new char[ blen ];
    memset( b, 0, blen );
    char *bsav = b;
    const char *from = s;
    unsigned flen = strlen( s );
    cnvUTF8ToSys( &from, &flen, &b, &blen );
    return bsav;
}

static void add_item( Environment *ev, PDFDoc *doc, LuIndexNode *n, GooList *items )
{
    if ( items == NULL ) {
        return;
    }

    int len = items->getLength();

    for ( int i = 0; i < len; i++ )
    {
        OutlineItem *item = (OutlineItem *)items->get( i );
        LinkAction *link_action = item->getAction();
        LuLink evlink;
        char *t1 = unicode_to_char( item->getTitle(), item->getTitleLength() );
        char *t2 = newstrFromUTF8( t1 );
        build_link( doc, &evlink, t2, link_action );
        delete t2;
        delete t1;
        LuIndexNode *cn = new LuIndexNode( ev, &evlink );
        n->addChild( ev, cn );

        item->open();
        if ( item->hasKids() )
        {
            GooList *citems = item->getKids();
            add_item( ev, doc, cn, citems );
        }
    }
}

SOM_Scope LuIndexNode*  SOMLINK getIndex(LuPopplerDocument *somSelf,
                                          Environment *ev)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PDFDoc *doc = ((PopplerDocument *)somThis->data)->doc;

    Outline *outline = doc->getOutline();
    if ( outline == NULL ) {
        return NULL;
    }

    GooList *items = outline->getItems();
    if ( items == NULL ) {
        return NULL;
    }

    LuIndexNode *root = new LuIndexNode( ev, NULL );
    add_item( ev, doc, root, items );

    return root;
}


static bool has_unicode_marker( GooString *string )
{
    return ( ( (string->getChar(0) & 0xff) == 0xfe ) &&
             ( (string->getChar(1) & 0xff) == 0xff ) );
}

// return SOMMalloc'ed string
static char *propcnv( GooString *s )
{
    if ( has_unicode_marker( s ) )
    {
        unsigned blen = s->getLength() * 2;
        char *b = (char *)SOMMalloc( blen );
        memset( b, 0, blen );
        char *bsav = b;
        const char *from = s->getCString() + 2;
        unsigned flen = s->getLength() - 2;
        cnvUniBEToSys( &from, &flen, &b, &blen );
        return bsav;
    }

    return somstrdup( s->getCString() );
}

static time_t propToDate( const char *date_string )
{
    int year, mon, day, hour, min, sec;
    int scanned_items;

    // See PDF Reference 1.3, Section 3.8.2 for PDF Date representation
    if ( ( date_string[0] == 'D' ) && ( date_string[1] == ':' ) ) {
        date_string += 2;
    }

    // FIXME only year is mandatory; parse optional timezone offset
    scanned_items = sscanf( date_string, "%4d%2d%2d%2d%2d%2d",
                            &year, &mon, &day, &hour, &min, &sec);

    if ( scanned_items != 6 ) {
        return (time_t)(-1);
    }

    // Workaround for y2k bug in Distiller 3, hoping that it won't
    // be used after y2.2k
    if ( ( year < 1930 ) && ( strlen( date_string ) > 14 ) )
    {
        int century, years_since_1900;
        scanned_items = sscanf( date_string, "%2d%3d%2d%2d%2d%2d%2d",
                &century, &years_since_1900, &mon, &day, &hour, &min, &sec );

        if ( scanned_items != 7 ) {
            return (time_t)(-1);
        }

        year = century * 100 + years_since_1900;
    }

    struct tm time = { 0 };
    time.tm_year  = year - 1900;
    time.tm_mon   = mon - 1;
    time.tm_mday  = day;
    time.tm_hour  = hour;
    time.tm_min   = min;
    time.tm_sec   = sec;
    time.tm_wday  = -1;
    time.tm_yday  = -1;
    time.tm_isdst = -1; // 0 = DST off, 1 = DST on, -1 = don't know

    return mktime( &time );
}

static long convPageMode( Catalog::PageMode pageMode )
{
    switch ( pageMode )
    {
        case Catalog::pageModeThumbs:
            return LU_DOCUMENT_MODE_USE_THUMBS;
        case Catalog::pageModeFullScreen:
            return LU_DOCUMENT_MODE_FULL_SCREEN;
        case Catalog::pageModeOC:
            return LU_DOCUMENT_MODE_USE_OC;
        case Catalog::pageModeAttach:
            return LU_DOCUMENT_MODE_USE_ATTACHMENTS;
        case Catalog::pageModeNone:
            return LU_DOCUMENT_MODE_NONE;
    }

    return -1;
}

static long convLayout( Catalog::PageLayout pageLayout )
{
    switch ( pageLayout )
    {
        case Catalog::pageLayoutSinglePage:
            return LU_DOCUMENT_LAYOUT_SINGLE_PAGE;
        case Catalog::pageLayoutOneColumn:
            return LU_DOCUMENT_LAYOUT_ONE_COLUMN;
        case Catalog::pageLayoutTwoColumnLeft:
            return LU_DOCUMENT_LAYOUT_TWO_COLUMN_LEFT;
        case Catalog::pageLayoutTwoColumnRight:
            return LU_DOCUMENT_LAYOUT_TWO_COLUMN_RIGHT;
        case Catalog::pageLayoutTwoPageLeft:
            return LU_DOCUMENT_LAYOUT_TWO_PAGE_LEFT;
        case Catalog::pageLayoutTwoPageRight:
            return LU_DOCUMENT_LAYOUT_TWO_PAGE_RIGHT;
    }
    return -1;
}

SOM_Scope LuDocumentInfo*  SOMLINK getDocumentInfo(LuPopplerDocument *somSelf,
                                                    Environment *ev)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PDFDoc *doc = ((PopplerDocument *)somThis->data)->doc;

    LuDocumentInfo *info = (LuDocumentInfo *)SOMMalloc( sizeof( LuDocumentInfo ) );
    memset( info, 0, sizeof( LuDocumentInfo ) );

    Object objdict;
    doc->getDocInfo( &objdict );
    if ( objdict.isDict() )
    {
        Dict *d = objdict.getDict();
        Object obj;

        if ( d->lookup( "Title", &obj )->isString() ) {
            info->title = propcnv( obj.getString() );
            info->fields_mask |= LU_DOCUMENT_INFO_TITLE;
        }
        obj.free();
        if ( d->lookup( "Author", &obj )->isString() ) {
            info->author = propcnv( obj.getString() );
            info->fields_mask |= LU_DOCUMENT_INFO_AUTHOR;
        }
        obj.free();
        if ( d->lookup( "Subject", &obj )->isString() ) {
            info->subject = propcnv( obj.getString() );
            info->fields_mask |= LU_DOCUMENT_INFO_SUBJECT;
        }
        obj.free();
        if ( d->lookup( "Keywords", &obj )->isString() ) {
            info->keywords = propcnv( obj.getString() );
            info->fields_mask |= LU_DOCUMENT_INFO_KEYWORDS;
        }
        obj.free();
        if ( d->lookup( "Creator", &obj )->isString() ) {
            info->creator = propcnv( obj.getString() );
            info->fields_mask |= LU_DOCUMENT_INFO_CREATOR;
        }
        obj.free();
        if ( d->lookup( "Producer", &obj )->isString() ) {
            info->producer = propcnv( obj.getString() );
            info->fields_mask |= LU_DOCUMENT_INFO_PRODUCER;
        }
        obj.free();
        if ( d->lookup( "CreationDate", &obj )->isString() ) {
            char *d = propcnv( obj.getString() );
            info->creation_date = propToDate( d );
            if ( (long)info->creation_date != -1 ) {
                info->fields_mask |= LU_DOCUMENT_INFO_CREATION_DATE;
            }
            SOMFree( d );
        }
        obj.free();
        if ( d->lookup( "ModDate", &obj )->isString() ) {
            char *d = propcnv( obj.getString() );
            info->modified_date = propToDate( d );
            if ( (long)info->modified_date != -1 ) {
                info->fields_mask |= LU_DOCUMENT_INFO_MOD_DATE;
            }
            SOMFree( d );
        }
        obj.free();
    }

    char *format = (char *)SOMMalloc( 16 );
    snprintf( format, 16, "PDF-%.2f", doc->getPDFVersion() );
    info->format = format;
    info->fields_mask |= LU_DOCUMENT_INFO_FORMAT;

    info->linearized = doc->isLinearized();
    info->fields_mask |= LU_DOCUMENT_INFO_LINEARIZED;

    Catalog *catalog = doc->getCatalog();

    if ( ( catalog != NULL ) && catalog->isOk() )
    {
        info->layout = convLayout( catalog->getPageLayout() );
        if ( info->layout != -1 ) {
            info->fields_mask |= LU_DOCUMENT_INFO_LAYOUT;
        }

        info->mode = convPageMode( catalog->getPageMode() );
        if ( info->mode != -1 ) {
            info->fields_mask |= LU_DOCUMENT_INFO_START_MODE;
        }
    }

    info->fields_mask |= LU_DOCUMENT_INFO_PERMISSIONS;
    if ( doc->okToPrint() ) {
        info->permissions |= LU_DOCUMENT_PERMISSIONS_OK_TO_PRINT;
    }
    if ( doc->okToChange() ) {
        info->permissions |= LU_DOCUMENT_PERMISSIONS_OK_TO_MODIFY;
    }
    if ( doc->okToCopy() ) {
        info->permissions |= LU_DOCUMENT_PERMISSIONS_OK_TO_COPY;
    }
    if ( doc->okToAddNotes() ) {
        info->permissions |= LU_DOCUMENT_PERMISSIONS_OK_TO_ADD_NOTES;
    }

    info->n_pages = doc->getNumPages();
    info->fields_mask |= LU_DOCUMENT_INFO_N_PAGES;

    return info;
}


SOM_Scope boolean  SOMLINK getThumbnailSize(LuPopplerDocument *somSelf,
                                             Environment *ev,
                                            long pagenum,
                                            short suggested_width,
                                            short* width, short* height)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    Page *page = ((PopplerDocument *)somThis->data)->pages[ pagenum ].page;

    Object thumb;
    Dict *dict;
    boolean retval = FALSE;

    page->getThumb( &thumb );
    if ( thumb.isNull() )
    {
        thumb.free();
        return FALSE;
    }

    dict = thumb.streamGetDict();

    // Theoretically, this could succeed and you would still fail when
    // loading the thumb
    int w = 0, h = 0;
    if ( dict->lookupInt( "Width", "W", &w ) && dict->lookupInt( "Height", "H", &h ) )
    {
        if ( width != NULL ) {
            *width = w;
        }
        if ( height != NULL ) {
            *height = h;
        }

        retval = TRUE;
    }

    thumb.free();

    return retval;
}

SOM_Scope LuPixbuf*  SOMLINK getThumbnail(LuPopplerDocument *somSelf,
                                           Environment *ev, long pagenum,
                                          short suggested_width)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    Page *page = ((PopplerDocument *)somThis->data)->pages[ pagenum ].page;

    unsigned char *data;
    int width, height, rowstride;

    if ( !page->loadThumb( &data, &width, &height, &rowstride ) ) {
        return NULL;
    }

    short bpp = getBpp( somSelf, ev );
    LuPixbuf *pixbuf = new LuPixbuf( ev, width, height, bpp );
    char *pixbuf_data = (char *)pixbuf->getDataPtr( ev );
    int pixbuf_rowstride = pixbuf->getRowSize( ev );
    char *src, *dst;
    int i, j;
    for ( i = 0, j = ( height - 1 ); i < height; i++, j-- )
    {
        src = data + ( j * rowstride );
        dst = pixbuf_data + (i * pixbuf_rowstride);
        for ( int k = 0; k < pixbuf_rowstride; k += bpp )
        {
            dst[ k ]     = src[ k + 2 ];
            dst[ k + 1 ] = src[ k + 1 ];
            dst[ k + 2 ] = src[ k ];
        }
    }
    gfree( data );

    return pixbuf;
}


SOM_Scope LuDocument_LuRectSequence*  SOMLINK searchText(LuPopplerDocument *somSelf,
                                                          Environment *ev,
                                                         long pagenum,
                                                         string text,
                                                         boolean caseSensitive)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData(somSelf);
    PopplerDocument *document = (PopplerDocument *)somThis->data;
    Page *page = document->pages[ pagenum ].page;

    DosRequestMutexSem( document->mutex, SEM_INDEFINITE_WAIT );
    TextOutputDev *output_dev = new TextOutputDev( NULL, gTrue, gFalse, gFalse );
    page->display( output_dev, 72, 72, 0, gFalse,
                   gTrue, NULL, document->doc->getCatalog() );
    DosReleaseMutexSem( document->mutex );


    // Convert string from system encoding to UCS-4
    // first, convert to UCS-2
    unsigned text_len = strlen( text );
    unsigned text_len_sav = text_len;
    unsigned ucs2_len = ( text_len + 1 ) * 2;
    char *ucs2 = new char[ ucs2_len ];
    memset( ucs2, 0, ucs2_len );
    char *ucs2sav = ucs2;
    cnvSysToUCS2( (const char **)&text, &text_len, &ucs2, &ucs2_len );
    // second, convert UCS-2 to UCS-4
    short *uucs2 = (short *)ucs2sav;
    unsigned ucs4_len = ( text_len_sav + 1 ) * 2;
    unsigned *ucs4 = new unsigned[ ucs4_len ];
    memset( ucs4, 0, ucs4_len * sizeof( unsigned ) );
    int real_ucs4_len = 0;
    for ( real_ucs4_len = 0; *uucs2; real_ucs4_len++ ) {
        ucs4[ real_ucs4_len ] = *uucs2++;
    }
    delete ucs2sav;
    // conversion end

    RectList *rl = new RectList;
    double xMin, yMin, xMax, yMax;
    xMin = 0;
    yMin = 0;
    while ( output_dev->findText( ucs4, real_ucs4_len,
                   gFalse, gTrue, // startAtTop, stopAtBottom
                   gTrue, gFalse, // startAtLast, stopAtLast
                   caseSensitive, gFalse, // caseSensitive, backwards
                   &xMin, &yMin, &xMax, &yMax ) )
    {
        LuRectangle r;
        r.x1 = xMin;
        r.y1 = yMin;
        r.x2 = xMax;
        r.y2 = yMax;
        rl->push_back( r );
    }
    delete ucs4;
    delete output_dev;

    LuDocument_LuRectSequence *rectangles = NULL;
    int len = rl->size();
    if ( len > 0 )
    {
        rectangles = (LuDocument_LuRectSequence *)SOMMalloc( sizeof( LuDocument_LuRectSequence ) );
        rectangles->_maximum = len;
        rectangles->_length = len;
        rectangles->_buffer = (LuRectangle *)SOMMalloc( sizeof( LuRectangle ) * len );

        for ( int i = 0; i < len; i++ )
        {
            rectangles->_buffer[ i ].x1 = (*rl)[i].x1;
            rectangles->_buffer[ i ].y1 = (*rl)[i].y1;
            rectangles->_buffer[ i ].x2 = (*rl)[i].x2;
            rectangles->_buffer[ i ].y2 = (*rl)[i].y2;
        }
    }
    delete rl;

    return rectangles;
}


SOM_Scope void SOMLINK somDefaultInit(LuPopplerDocument *somSelf,
                                      som3InitCtrl* ctrl)
{
    // generated section - do not modify
    LuPopplerDocumentData *somThis;
    somInitCtrl globalCtrl;
    somBooleanVector myMask;
    LuPopplerDocument_BeginInitializer_somDefaultInit;
    LuPopplerDocument_Init_LuDocument_somDefaultInit(somSelf, ctrl);
    // end of generated section

    // local LuPopplerDocument initialization code
    PopplerDocument *d = new PopplerDocument;
    somThis->data = d;
}


static void set_error( char **error, const char *fmt, ... )
{
    if ( error == NULL ) {
        return;
    }

    va_list argptr;
    va_start( argptr, fmt );
    char *msg = new char[ 1000 ];
    vsnprintf( msg, 1000, fmt, argptr );
    *error = somstrdup( msg );
    delete msg;
}


SOM_Scope boolean  SOMLINK loadFile(LuPopplerDocument *somSelf,
                                    Environment *ev, string filename,
                                    string password, string* error)
{
    LuPopplerDocumentData *somThis = LuPopplerDocumentGetData( somSelf );

    PDFDoc *newDoc;
    GooString *filename_g;
    GooString *password_g;
    int err;

    if ( !globalParams ) {
        globalParams = new GlobalParams( NULL );
    }

    filename_g = new GooString(filename);

    password_g = NULL;
    if (password != NULL) {
        password_g = new GooString(password);
    }

    newDoc = new PDFDoc(filename_g, password_g, password_g);
    if (password_g) {
        delete password_g;
    }

    if (!newDoc->isOk()) {
        err = newDoc->getErrorCode();
        delete newDoc;

        if (err == errEncrypted) {
            set_error(error, "Document is encrypted.");
        } else {
            set_error(error, "Failed to load document (error %d) '%s'\n", err, filename );
        }

        return FALSE;
    }

    PopplerDocument *document = (PopplerDocument *)somThis->data;

    document->doc = newDoc;
    SplashColor white;
    white[0] = 255;
    white[1] = 255;
    white[2] = 255;
    document->output_dev = new SplashOutputDev( splashModeRGB8, 4, gFalse, white );
    document->output_dev->startDoc( document->doc->getXRef() );

    long numpages = document->doc->getNumPages();
    document->pages = new PopplerPage[ numpages ];
    for ( long pagenum = 0; pagenum < numpages; pagenum++ ) {
        document->pages[ pagenum ].page =
            document->doc->getCatalog()->getPage( pagenum + 1 );
    }

    return TRUE;
}


SOM_Scope void SOMLINK somDestruct(LuPopplerDocument *somSelf,
                                   octet doFree, som3DestructCtrl* ctrl)
{
    LuPopplerDocumentData *somThis;
    somDestructCtrl globalCtrl;
    somBooleanVector myMask;
    LuPopplerDocument_BeginDestructor;

    // local LuPopplerDocument deinitialization code
    PopplerDocument *document = (PopplerDocument *)somThis->data;
    delete document;
    // end of local LuPopplerDocument deinitialization code

    LuPopplerDocument_EndDestructor;
}


